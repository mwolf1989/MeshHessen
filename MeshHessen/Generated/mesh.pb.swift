// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mesh.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Meshtastic_HardwareModel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unset // = 0
  case tloraV2 // = 1
  case tloraV1 // = 2
  case tloraV211P6 // = 3
  case tbeam // = 4
  case heltecV20 // = 5
  case tbeamV0P7 // = 6
  case tEcho // = 7
  case tloraV11P3 // = 8
  case rak4631 // = 9
  case heltecV21 // = 10
  case heltecV1 // = 11
  case lilygoTbeamS3Core // = 12
  case rak11200 // = 13
  case nanoG1 // = 14
  case tloraV211P8 // = 15
  case tloraT3S3 // = 16
  case nanoG1Explorer // = 17
  case nanoG2Ultra // = 18
  case tbeamS3Core // = 19
  case rak11310 // = 20
  case stationG1 // = 25
  case rakMeshtasticStarterKit // = 26
  case heltecV3 // = 27
  case heltecWslV3 // = 28
  case betafpv2400Tx // = 29
  case betafpv900NanoTx // = 30
  case rpiPico // = 31
  case stationG2 // = 32
  case loraType // = 33
  case wiphone // = 34
  case wioWm1110 // = 35
  case rak2560 // = 36
  case heltecHru3601 // = 37
  case heltecWirelessPaperV10 // = 38
  case tDeck // = 39
  case tWatchS3 // = 40
  case picomputerS3 // = 41
  case heltecHt62 // = 42
  case ebyteEsp32S3 // = 43
  case esp32S3Pico // = 44
  case chatter2 // = 45
  case heltecWirelessPaper // = 46
  case heltecWirelessTracker // = 47
  case privateHw // = 255
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .tloraV2
    case 2: self = .tloraV1
    case 3: self = .tloraV211P6
    case 4: self = .tbeam
    case 5: self = .heltecV20
    case 6: self = .tbeamV0P7
    case 7: self = .tEcho
    case 8: self = .tloraV11P3
    case 9: self = .rak4631
    case 10: self = .heltecV21
    case 11: self = .heltecV1
    case 12: self = .lilygoTbeamS3Core
    case 13: self = .rak11200
    case 14: self = .nanoG1
    case 15: self = .tloraV211P8
    case 16: self = .tloraT3S3
    case 17: self = .nanoG1Explorer
    case 18: self = .nanoG2Ultra
    case 19: self = .tbeamS3Core
    case 20: self = .rak11310
    case 25: self = .stationG1
    case 26: self = .rakMeshtasticStarterKit
    case 27: self = .heltecV3
    case 28: self = .heltecWslV3
    case 29: self = .betafpv2400Tx
    case 30: self = .betafpv900NanoTx
    case 31: self = .rpiPico
    case 32: self = .stationG2
    case 33: self = .loraType
    case 34: self = .wiphone
    case 35: self = .wioWm1110
    case 36: self = .rak2560
    case 37: self = .heltecHru3601
    case 38: self = .heltecWirelessPaperV10
    case 39: self = .tDeck
    case 40: self = .tWatchS3
    case 41: self = .picomputerS3
    case 42: self = .heltecHt62
    case 43: self = .ebyteEsp32S3
    case 44: self = .esp32S3Pico
    case 45: self = .chatter2
    case 46: self = .heltecWirelessPaper
    case 47: self = .heltecWirelessTracker
    case 255: self = .privateHw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .tloraV2: return 1
    case .tloraV1: return 2
    case .tloraV211P6: return 3
    case .tbeam: return 4
    case .heltecV20: return 5
    case .tbeamV0P7: return 6
    case .tEcho: return 7
    case .tloraV11P3: return 8
    case .rak4631: return 9
    case .heltecV21: return 10
    case .heltecV1: return 11
    case .lilygoTbeamS3Core: return 12
    case .rak11200: return 13
    case .nanoG1: return 14
    case .tloraV211P8: return 15
    case .tloraT3S3: return 16
    case .nanoG1Explorer: return 17
    case .nanoG2Ultra: return 18
    case .tbeamS3Core: return 19
    case .rak11310: return 20
    case .stationG1: return 25
    case .rakMeshtasticStarterKit: return 26
    case .heltecV3: return 27
    case .heltecWslV3: return 28
    case .betafpv2400Tx: return 29
    case .betafpv900NanoTx: return 30
    case .rpiPico: return 31
    case .stationG2: return 32
    case .loraType: return 33
    case .wiphone: return 34
    case .wioWm1110: return 35
    case .rak2560: return 36
    case .heltecHru3601: return 37
    case .heltecWirelessPaperV10: return 38
    case .tDeck: return 39
    case .tWatchS3: return 40
    case .picomputerS3: return 41
    case .heltecHt62: return 42
    case .ebyteEsp32S3: return 43
    case .esp32S3Pico: return 44
    case .chatter2: return 45
    case .heltecWirelessPaper: return 46
    case .heltecWirelessTracker: return 47
    case .privateHw: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_HardwareModel] = [
    .unset,
    .tloraV2,
    .tloraV1,
    .tloraV211P6,
    .tbeam,
    .heltecV20,
    .tbeamV0P7,
    .tEcho,
    .tloraV11P3,
    .rak4631,
    .heltecV21,
    .heltecV1,
    .lilygoTbeamS3Core,
    .rak11200,
    .nanoG1,
    .tloraV211P8,
    .tloraT3S3,
    .nanoG1Explorer,
    .nanoG2Ultra,
    .tbeamS3Core,
    .rak11310,
    .stationG1,
    .rakMeshtasticStarterKit,
    .heltecV3,
    .heltecWslV3,
    .betafpv2400Tx,
    .betafpv900NanoTx,
    .rpiPico,
    .stationG2,
    .loraType,
    .wiphone,
    .wioWm1110,
    .rak2560,
    .heltecHru3601,
    .heltecWirelessPaperV10,
    .tDeck,
    .tWatchS3,
    .picomputerS3,
    .heltecHt62,
    .ebyteEsp32S3,
    .esp32S3Pico,
    .chatter2,
    .heltecWirelessPaper,
    .heltecWirelessTracker,
    .privateHw,
  ]

}

enum Meshtastic_Role: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case client // = 0
  case clientMute // = 1
  case router // = 2
  case routerClient // = 3
  case repeater // = 4
  case tracker // = 5
  case sensor // = 6
  case tak // = 7
  case clientHidden // = 8
  case lostAndFound // = 9
  case takTracker // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .client
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .client
    case 1: self = .clientMute
    case 2: self = .router
    case 3: self = .routerClient
    case 4: self = .repeater
    case 5: self = .tracker
    case 6: self = .sensor
    case 7: self = .tak
    case 8: self = .clientHidden
    case 9: self = .lostAndFound
    case 10: self = .takTracker
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .client: return 0
    case .clientMute: return 1
    case .router: return 2
    case .routerClient: return 3
    case .repeater: return 4
    case .tracker: return 5
    case .sensor: return 6
    case .tak: return 7
    case .clientHidden: return 8
    case .lostAndFound: return 9
    case .takTracker: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_Role] = [
    .client,
    .clientMute,
    .router,
    .routerClient,
    .repeater,
    .tracker,
    .sensor,
    .tak,
    .clientHidden,
    .lostAndFound,
    .takTracker,
  ]

}

enum Meshtastic_ChannelRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case disabled // = 0
  case primary // = 1
  case secondary // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .disabled
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disabled
    case 1: self = .primary
    case 2: self = .secondary
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .disabled: return 0
    case .primary: return 1
    case .secondary: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_ChannelRole] = [
    .disabled,
    .primary,
    .secondary,
  ]

}

enum Meshtastic_Priority: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unsetPriority // = 0
  case min // = 1
  case background // = 10
  case `default` // = 64
  case reliable // = 70
  case ack // = 120
  case max // = 127
  case UNRECOGNIZED(Int)

  init() {
    self = .unsetPriority
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unsetPriority
    case 1: self = .min
    case 10: self = .background
    case 64: self = .default
    case 70: self = .reliable
    case 120: self = .ack
    case 127: self = .max
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unsetPriority: return 0
    case .min: return 1
    case .background: return 10
    case .default: return 64
    case .reliable: return 70
    case .ack: return 120
    case .max: return 127
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_Priority] = [
    .unsetPriority,
    .min,
    .background,
    .default,
    .reliable,
    .ack,
    .max,
  ]

}

enum Meshtastic_Region: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unsetRegion // = 0
  case us // = 1
  case eu868 // = 3
  case cn // = 4
  case jp // = 5
  case anz // = 6
  case kr // = 7
  case tw // = 8
  case ru // = 9
  case `in` // = 10
  case nz865 // = 11
  case th // = 12
  case ua868 // = 13
  case my919 // = 14
  case sg923 // = 15
  case lora24 // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .unsetRegion
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unsetRegion
    case 1: self = .us
    case 3: self = .eu868
    case 4: self = .cn
    case 5: self = .jp
    case 6: self = .anz
    case 7: self = .kr
    case 8: self = .tw
    case 9: self = .ru
    case 10: self = .in
    case 11: self = .nz865
    case 12: self = .th
    case 13: self = .ua868
    case 14: self = .my919
    case 15: self = .sg923
    case 16: self = .lora24
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unsetRegion: return 0
    case .us: return 1
    case .eu868: return 3
    case .cn: return 4
    case .jp: return 5
    case .anz: return 6
    case .kr: return 7
    case .tw: return 8
    case .ru: return 9
    case .in: return 10
    case .nz865: return 11
    case .th: return 12
    case .ua868: return 13
    case .my919: return 14
    case .sg923: return 15
    case .lora24: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_Region] = [
    .unsetRegion,
    .us,
    .eu868,
    .cn,
    .jp,
    .anz,
    .kr,
    .tw,
    .ru,
    .in,
    .nz865,
    .th,
    .ua868,
    .my919,
    .sg923,
    .lora24,
  ]

}

enum Meshtastic_ModemPreset: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case longFast // = 0
  case longSlow // = 1
  case veryLongSlow // = 2
  case mediumSlow // = 3
  case mediumFast // = 4
  case shortSlow // = 5
  case shortFast // = 6
  case longModerate // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .longFast
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .longFast
    case 1: self = .longSlow
    case 2: self = .veryLongSlow
    case 3: self = .mediumSlow
    case 4: self = .mediumFast
    case 5: self = .shortSlow
    case 6: self = .shortFast
    case 7: self = .longModerate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .longFast: return 0
    case .longSlow: return 1
    case .veryLongSlow: return 2
    case .mediumSlow: return 3
    case .mediumFast: return 4
    case .shortSlow: return 5
    case .shortFast: return 6
    case .longModerate: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_ModemPreset] = [
    .longFast,
    .longSlow,
    .veryLongSlow,
    .mediumSlow,
    .mediumFast,
    .shortSlow,
    .shortFast,
    .longModerate,
  ]

}

enum Meshtastic_GpsCoordinateFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case dec // = 0
  case dms // = 1
  case utm // = 2
  case mgrs // = 3
  case olc // = 4
  case osgr // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .dec
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dec
    case 1: self = .dms
    case 2: self = .utm
    case 3: self = .mgrs
    case 4: self = .olc
    case 5: self = .osgr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .dec: return 0
    case .dms: return 1
    case .utm: return 2
    case .mgrs: return 3
    case .olc: return 4
    case .osgr: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Meshtastic_GpsCoordinateFormat] = [
    .dec,
    .dms,
    .utm,
    .mgrs,
    .olc,
    .osgr,
  ]

}

struct Meshtastic_Position: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitudeI: Int32 = 0

  var longitudeI: Int32 = 0

  var altitude: Int32 = 0

  var time: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var longName: String = String()

  var shortName: String = String()

  var macaddr: Data = Data()

  var hwModel: Meshtastic_HardwareModel = .unset

  var isLicensed: Bool = false

  var role: Meshtastic_Role = .client

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_RouteDiscovery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var route: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_Data: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var portnum: UInt32 = 0

  var payload: Data = Data()

  var wantResponse: Bool = false

  var dest: UInt32 = 0

  var source: UInt32 = 0

  var requestID: UInt32 = 0

  var replyID: UInt32 = 0

  var emoji: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_Routing: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variant: Meshtastic_Routing.OneOf_Variant? = nil

  var routeRequest: Meshtastic_RouteDiscovery {
    get {
      if case .routeRequest(let v)? = variant {return v}
      return Meshtastic_RouteDiscovery()
    }
    set {variant = .routeRequest(newValue)}
  }

  var routeReply: Meshtastic_RouteDiscovery {
    get {
      if case .routeReply(let v)? = variant {return v}
      return Meshtastic_RouteDiscovery()
    }
    set {variant = .routeReply(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Variant: Equatable, Sendable {
    case routeRequest(Meshtastic_RouteDiscovery)
    case routeReply(Meshtastic_RouteDiscovery)

  }

  init() {}
}

struct Meshtastic_MeshPacket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: UInt32 {
    get {_storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  var to: UInt32 {
    get {_storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  var channel: UInt32 {
    get {_storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  var payloadVariant: OneOf_PayloadVariant? {
    get {return _storage._payloadVariant}
    set {_uniqueStorage()._payloadVariant = newValue}
  }

  var decoded: Meshtastic_Data {
    get {
      if case .decoded(let v)? = _storage._payloadVariant {return v}
      return Meshtastic_Data()
    }
    set {_uniqueStorage()._payloadVariant = .decoded(newValue)}
  }

  var encrypted: Data {
    get {
      if case .encrypted(let v)? = _storage._payloadVariant {return v}
      return Data()
    }
    set {_uniqueStorage()._payloadVariant = .encrypted(newValue)}
  }

  var id: UInt32 {
    get {_storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var rxTime: UInt32 {
    get {_storage._rxTime}
    set {_uniqueStorage()._rxTime = newValue}
  }

  var rxSnr: Float {
    get {_storage._rxSnr}
    set {_uniqueStorage()._rxSnr = newValue}
  }

  var rxRssi: Int32 {
    get {_storage._rxRssi}
    set {_uniqueStorage()._rxRssi = newValue}
  }

  var hopLimit: UInt32 {
    get {_storage._hopLimit}
    set {_uniqueStorage()._hopLimit = newValue}
  }

  var wantAck: Bool {
    get {_storage._wantAck}
    set {_uniqueStorage()._wantAck = newValue}
  }

  var priority: Meshtastic_Priority {
    get {_storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  var hopStart: Int32 {
    get {_storage._hopStart}
    set {_uniqueStorage()._hopStart = newValue}
  }

  var viaMqtt: Bool {
    get {_storage._viaMqtt}
    set {_uniqueStorage()._viaMqtt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable, Sendable {
    case decoded(Meshtastic_Data)
    case encrypted(Data)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Meshtastic_NodeInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var num: UInt32 {
    get {_storage._num}
    set {_uniqueStorage()._num = newValue}
  }

  var user: Meshtastic_User {
    get {_storage._user ?? Meshtastic_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {_storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var position: Meshtastic_Position {
    get {_storage._position ?? Meshtastic_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {_storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  var snr: Float {
    get {_storage._snr}
    set {_uniqueStorage()._snr = newValue}
  }

  var lastHeard: Int32 {
    get {_storage._lastHeard}
    set {_uniqueStorage()._lastHeard = newValue}
  }

  var deviceMetrics: Meshtastic_DeviceMetrics {
    get {_storage._deviceMetrics ?? Meshtastic_DeviceMetrics()}
    set {_uniqueStorage()._deviceMetrics = newValue}
  }
  /// Returns true if `deviceMetrics` has been explicitly set.
  var hasDeviceMetrics: Bool {_storage._deviceMetrics != nil}
  /// Clears the value of `deviceMetrics`. Subsequent reads from it will return its default value.
  mutating func clearDeviceMetrics() {_uniqueStorage()._deviceMetrics = nil}

  var channel: UInt32 {
    get {_storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  var viaMqtt: Bool {
    get {_storage._viaMqtt}
    set {_uniqueStorage()._viaMqtt = newValue}
  }

  var hopsAway: UInt32 {
    get {_storage._hopsAway}
    set {_uniqueStorage()._hopsAway = newValue}
  }

  var isFavorite: Bool {
    get {_storage._isFavorite}
    set {_uniqueStorage()._isFavorite = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Meshtastic_MyNodeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var myNodeNum: UInt32 = 0

  var rebootCount: UInt32 = 0

  var minAppVersion: UInt32 = 0

  var maxChannels: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_DeviceMetrics: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var batteryLevel: UInt32 = 0

  var voltage: Float = 0

  var channelUtilization: Float = 0

  var airUtilTx: Float = 0

  var uptimeSeconds: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_FromRadio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var payloadVariant: Meshtastic_FromRadio.OneOf_PayloadVariant? = nil

  var packet: Meshtastic_MeshPacket {
    get {
      if case .packet(let v)? = payloadVariant {return v}
      return Meshtastic_MeshPacket()
    }
    set {payloadVariant = .packet(newValue)}
  }

  var myInfo: Meshtastic_MyNodeInfo {
    get {
      if case .myInfo(let v)? = payloadVariant {return v}
      return Meshtastic_MyNodeInfo()
    }
    set {payloadVariant = .myInfo(newValue)}
  }

  var nodeInfo: Meshtastic_NodeInfo {
    get {
      if case .nodeInfo(let v)? = payloadVariant {return v}
      return Meshtastic_NodeInfo()
    }
    set {payloadVariant = .nodeInfo(newValue)}
  }

  var config: Meshtastic_Config {
    get {
      if case .config(let v)? = payloadVariant {return v}
      return Meshtastic_Config()
    }
    set {payloadVariant = .config(newValue)}
  }

  var moduleConfig: Meshtastic_ModuleConfig {
    get {
      if case .moduleConfig(let v)? = payloadVariant {return v}
      return Meshtastic_ModuleConfig()
    }
    set {payloadVariant = .moduleConfig(newValue)}
  }

  var channel: Meshtastic_Channel {
    get {
      if case .channel(let v)? = payloadVariant {return v}
      return Meshtastic_Channel()
    }
    set {payloadVariant = .channel(newValue)}
  }

  var configCompleteID: Data {
    get {
      if case .configCompleteID(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .configCompleteID(newValue)}
  }

  var rebooted: Data {
    get {
      if case .rebooted(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .rebooted(newValue)}
  }

  var moduleconfigCompleteID: Data {
    get {
      if case .moduleconfigCompleteID(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .moduleconfigCompleteID(newValue)}
  }

  var channelsCompleteID: Data {
    get {
      if case .channelsCompleteID(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .channelsCompleteID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable, Sendable {
    case packet(Meshtastic_MeshPacket)
    case myInfo(Meshtastic_MyNodeInfo)
    case nodeInfo(Meshtastic_NodeInfo)
    case config(Meshtastic_Config)
    case moduleConfig(Meshtastic_ModuleConfig)
    case channel(Meshtastic_Channel)
    case configCompleteID(Data)
    case rebooted(Data)
    case moduleconfigCompleteID(Data)
    case channelsCompleteID(Data)

  }

  init() {}
}

struct Meshtastic_ToRadio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payloadVariant: Meshtastic_ToRadio.OneOf_PayloadVariant? = nil

  var packet: Meshtastic_MeshPacket {
    get {
      if case .packet(let v)? = payloadVariant {return v}
      return Meshtastic_MeshPacket()
    }
    set {payloadVariant = .packet(newValue)}
  }

  var wantConfigID: UInt32 {
    get {
      if case .wantConfigID(let v)? = payloadVariant {return v}
      return 0
    }
    set {payloadVariant = .wantConfigID(newValue)}
  }

  var disconnect: Bool {
    get {
      if case .disconnect(let v)? = payloadVariant {return v}
      return false
    }
    set {payloadVariant = .disconnect(newValue)}
  }

  var xmodemPacket: Data {
    get {
      if case .xmodemPacket(let v)? = payloadVariant {return v}
      return Data()
    }
    set {payloadVariant = .xmodemPacket(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable, Sendable {
    case packet(Meshtastic_MeshPacket)
    case wantConfigID(UInt32)
    case disconnect(Bool)
    case xmodemPacket(Data)

  }

  init() {}
}

struct Meshtastic_Channel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: Int32 = 0

  var settings: Meshtastic_ChannelSettings {
    get {_settings ?? Meshtastic_ChannelSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {self._settings = nil}

  var role: Meshtastic_ChannelRole = .disabled

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _settings: Meshtastic_ChannelSettings? = nil
}

struct Meshtastic_ChannelSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelNum: UInt32 = 0

  var psk: Data = Data()

  var name: String = String()

  var id: UInt32 = 0

  var uplinkEnabled: Bool = false

  var downlinkEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payloadVariant: Meshtastic_Config.OneOf_PayloadVariant? = nil

  var device: Meshtastic_DeviceConfig {
    get {
      if case .device(let v)? = payloadVariant {return v}
      return Meshtastic_DeviceConfig()
    }
    set {payloadVariant = .device(newValue)}
  }

  var position: Meshtastic_PositionConfig {
    get {
      if case .position(let v)? = payloadVariant {return v}
      return Meshtastic_PositionConfig()
    }
    set {payloadVariant = .position(newValue)}
  }

  var power: Meshtastic_PowerConfig {
    get {
      if case .power(let v)? = payloadVariant {return v}
      return Meshtastic_PowerConfig()
    }
    set {payloadVariant = .power(newValue)}
  }

  var network: Meshtastic_NetworkConfig {
    get {
      if case .network(let v)? = payloadVariant {return v}
      return Meshtastic_NetworkConfig()
    }
    set {payloadVariant = .network(newValue)}
  }

  var display: Meshtastic_DisplayConfig {
    get {
      if case .display(let v)? = payloadVariant {return v}
      return Meshtastic_DisplayConfig()
    }
    set {payloadVariant = .display(newValue)}
  }

  var lora: Meshtastic_LoRaConfig {
    get {
      if case .lora(let v)? = payloadVariant {return v}
      return Meshtastic_LoRaConfig()
    }
    set {payloadVariant = .lora(newValue)}
  }

  var bluetooth: Meshtastic_BluetoothConfig {
    get {
      if case .bluetooth(let v)? = payloadVariant {return v}
      return Meshtastic_BluetoothConfig()
    }
    set {payloadVariant = .bluetooth(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable, Sendable {
    case device(Meshtastic_DeviceConfig)
    case position(Meshtastic_PositionConfig)
    case power(Meshtastic_PowerConfig)
    case network(Meshtastic_NetworkConfig)
    case display(Meshtastic_DisplayConfig)
    case lora(Meshtastic_LoRaConfig)
    case bluetooth(Meshtastic_BluetoothConfig)

  }

  init() {}
}

struct Meshtastic_DeviceConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var role: Meshtastic_Role = .client

  var serialEnabled: Bool = false

  var rebroadcastMode: UInt32 = 0

  var nodeInfoBroadcastSecs: UInt32 = 0

  var doubleTapAsButtonPress: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_PositionConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var positionBroadcastSecs: UInt32 = 0

  var positionBroadcastSmartEnabled: Bool = false

  var gpsUpdateInterval: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_PowerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isPowerSaving: Bool = false

  var onBatteryShutdownAfterSecs: UInt32 = 0

  var adcMultiplierOverride: UInt32 = 0

  var waitBluetoothSecs: UInt32 = 0

  var sdsSecs: UInt32 = 0

  var lsSecs: UInt32 = 0

  var minWakeSecs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_NetworkConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wifiEnabled: Bool = false

  var wifiSsid: String = String()

  var wifiPsk: String = String()

  var ntpServer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_DisplayConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenOnSecs: UInt32 = 0

  var autoScreenCarouselSecs: Bool = false

  var compassNorthTop: Bool = false

  var flipScreen: Bool = false

  var gpsFormat: Meshtastic_GpsCoordinateFormat = .dec

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_LoRaConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var usePreset: Bool = false

  var modemPreset: Meshtastic_ModemPreset = .longFast

  var bandwidth: UInt32 = 0

  var spreadFactor: UInt32 = 0

  var codingRate: UInt32 = 0

  var frequencyOffset: UInt32 = 0

  var region: Meshtastic_Region = .unsetRegion

  var hopLimit: UInt32 = 0

  var txEnabled: Bool = false

  var txPower: Float = 0

  var channelNum: UInt32 = 0

  var overrideDutyCycle: Bool = false

  var sx126XRxBoostedGain: Bool = false

  var overrideFrequency: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_BluetoothConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var mode: UInt32 = 0

  var fixedPin: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_ModuleConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payloadVariant: Meshtastic_ModuleConfig.OneOf_PayloadVariant? = nil

  var mqtt: Meshtastic_MQTTConfig {
    get {
      if case .mqtt(let v)? = payloadVariant {return v}
      return Meshtastic_MQTTConfig()
    }
    set {payloadVariant = .mqtt(newValue)}
  }

  var serial: Meshtastic_SerialConfig {
    get {
      if case .serial(let v)? = payloadVariant {return v}
      return Meshtastic_SerialConfig()
    }
    set {payloadVariant = .serial(newValue)}
  }

  var externalNotification: Meshtastic_ExternalNotificationConfig {
    get {
      if case .externalNotification(let v)? = payloadVariant {return v}
      return Meshtastic_ExternalNotificationConfig()
    }
    set {payloadVariant = .externalNotification(newValue)}
  }

  var storeForward: Meshtastic_StoreForwardConfig {
    get {
      if case .storeForward(let v)? = payloadVariant {return v}
      return Meshtastic_StoreForwardConfig()
    }
    set {payloadVariant = .storeForward(newValue)}
  }

  var rangeTest: Meshtastic_RangeTestConfig {
    get {
      if case .rangeTest(let v)? = payloadVariant {return v}
      return Meshtastic_RangeTestConfig()
    }
    set {payloadVariant = .rangeTest(newValue)}
  }

  var telemetry: Meshtastic_TelemetryConfig {
    get {
      if case .telemetry(let v)? = payloadVariant {return v}
      return Meshtastic_TelemetryConfig()
    }
    set {payloadVariant = .telemetry(newValue)}
  }

  var cannedMessage: Meshtastic_CannedMessageConfig {
    get {
      if case .cannedMessage(let v)? = payloadVariant {return v}
      return Meshtastic_CannedMessageConfig()
    }
    set {payloadVariant = .cannedMessage(newValue)}
  }

  var audio: Meshtastic_AudioConfig {
    get {
      if case .audio(let v)? = payloadVariant {return v}
      return Meshtastic_AudioConfig()
    }
    set {payloadVariant = .audio(newValue)}
  }

  var remoteHardware: Meshtastic_RemoteHardwareConfig {
    get {
      if case .remoteHardware(let v)? = payloadVariant {return v}
      return Meshtastic_RemoteHardwareConfig()
    }
    set {payloadVariant = .remoteHardware(newValue)}
  }

  var neighborInfo: Meshtastic_NeighborInfoConfig {
    get {
      if case .neighborInfo(let v)? = payloadVariant {return v}
      return Meshtastic_NeighborInfoConfig()
    }
    set {payloadVariant = .neighborInfo(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadVariant: Equatable, Sendable {
    case mqtt(Meshtastic_MQTTConfig)
    case serial(Meshtastic_SerialConfig)
    case externalNotification(Meshtastic_ExternalNotificationConfig)
    case storeForward(Meshtastic_StoreForwardConfig)
    case rangeTest(Meshtastic_RangeTestConfig)
    case telemetry(Meshtastic_TelemetryConfig)
    case cannedMessage(Meshtastic_CannedMessageConfig)
    case audio(Meshtastic_AudioConfig)
    case remoteHardware(Meshtastic_RemoteHardwareConfig)
    case neighborInfo(Meshtastic_NeighborInfoConfig)

  }

  init() {}
}

struct Meshtastic_MQTTConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var address: String = String()

  var username: String = String()

  var password: String = String()

  var encryptionEnabled: Bool = false

  var jsonEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_SerialConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var echo: Bool = false

  var rxd: UInt32 = 0

  var txd: UInt32 = 0

  var baud: UInt32 = 0

  var timeout: UInt32 = 0

  var mode: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_ExternalNotificationConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var outputMs: UInt32 = 0

  var output: UInt32 = 0

  var active: Bool = false

  var alertMessage: Bool = false

  var alertBell: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_StoreForwardConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var heartbeat: Bool = false

  var records: UInt32 = 0

  var historyReturnMax: UInt32 = 0

  var historyReturnWindow: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_RangeTestConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var sender: UInt32 = 0

  var save: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_TelemetryConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUpdateInterval: UInt32 = 0

  var environmentUpdateInterval: UInt32 = 0

  var environmentDisplayFahrenheit: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_CannedMessageConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rotary1Enabled: Bool = false

  var inputbrokerPinPress: UInt32 = 0

  var inputbrokerEventCw: UInt32 = 0

  var inputbrokerEventCcw: UInt32 = 0

  var inputbrokerEventPress: UInt32 = 0

  var updown1Enabled: Bool = false

  var enabled: Bool = false

  var allowInputSource: String = String()

  var sendBell: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_AudioConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codec2Enabled: Bool = false

  var pttPin: UInt32 = 0

  var bitrate: Bool = false

  var i2SWs: UInt32 = 0

  var i2SSd: UInt32 = 0

  var i2SDin: UInt32 = 0

  var i2SSck: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_RemoteHardwareConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var allowUndefinedPinAccess: Bool = false

  var availablePins: [Meshtastic_RemoteHardwarePin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_RemoteHardwarePin: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gpioPin: UInt32 = 0

  var name: String = String()

  var type: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Meshtastic_NeighborInfoConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var updateInterval: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meshtastic"

extension Meshtastic_HardwareModel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSET\0\u{1}TLORA_V2\0\u{1}TLORA_V1\0\u{1}TLORA_V2_1_1P6\0\u{1}TBEAM\0\u{1}HELTEC_V2_0\0\u{1}TBEAM_V0P7\0\u{1}T_ECHO\0\u{1}TLORA_V1_1P3\0\u{1}RAK4631\0\u{1}HELTEC_V2_1\0\u{1}HELTEC_V1\0\u{1}LILYGO_TBEAM_S3_CORE\0\u{1}RAK11200\0\u{1}NANO_G1\0\u{1}TLORA_V2_1_1P8\0\u{1}TLORA_T3_S3\0\u{1}NANO_G1_EXPLORER\0\u{1}NANO_G2_ULTRA\0\u{1}TBEAM_S3_CORE\0\u{1}RAK11310\0\u{2}\u{5}STATION_G1\0\u{1}RAK_MESHTASTIC_STARTER_KIT\0\u{1}HELTEC_V3\0\u{1}HELTEC_WSL_V3\0\u{1}BETAFPV_2400_TX\0\u{1}BETAFPV_900_NANO_TX\0\u{1}RPI_PICO\0\u{1}STATION_G2\0\u{1}LORA_TYPE\0\u{1}WIPHONE\0\u{1}WIO_WM1110\0\u{1}RAK2560\0\u{1}HELTEC_HRU_3601\0\u{1}HELTEC_WIRELESS_PAPER_V1_0\0\u{1}T_DECK\0\u{1}T_WATCH_S3\0\u{1}PICOMPUTER_S3\0\u{1}HELTEC_HT62\0\u{1}EBYTE_ESP32_S3\0\u{1}ESP32_S3_PICO\0\u{1}CHATTER_2\0\u{1}HELTEC_WIRELESS_PAPER\0\u{1}HELTEC_WIRELESS_TRACKER\0\u{2}P\u{3}PRIVATE_HW\0")
}

extension Meshtastic_Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLIENT\0\u{1}CLIENT_MUTE\0\u{1}ROUTER\0\u{1}ROUTER_CLIENT\0\u{1}REPEATER\0\u{1}TRACKER\0\u{1}SENSOR\0\u{1}TAK\0\u{1}CLIENT_HIDDEN\0\u{1}LOST_AND_FOUND\0\u{1}TAK_TRACKER\0")
}

extension Meshtastic_ChannelRole: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DISABLED\0\u{1}PRIMARY\0\u{1}SECONDARY\0")
}

extension Meshtastic_Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSET_PRIORITY\0\u{1}MIN\0\u{2}\u{9}BACKGROUND\0\u{2}6DEFAULT\0\u{2}\u{6}RELIABLE\0\u{2}2ACK\0\u{2}\u{7}MAX\0")
}

extension Meshtastic_Region: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSET_REGION\0\u{1}US\0\u{2}\u{2}EU_868\0\u{1}CN\0\u{1}JP\0\u{1}ANZ\0\u{1}KR\0\u{1}TW\0\u{1}RU\0\u{1}IN\0\u{1}NZ_865\0\u{1}TH\0\u{1}UA_868\0\u{1}MY_919\0\u{1}SG_923\0\u{1}LORA_24\0")
}

extension Meshtastic_ModemPreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LONG_FAST\0\u{1}LONG_SLOW\0\u{1}VERY_LONG_SLOW\0\u{1}MEDIUM_SLOW\0\u{1}MEDIUM_FAST\0\u{1}SHORT_SLOW\0\u{1}SHORT_FAST\0\u{1}LONG_MODERATE\0")
}

extension Meshtastic_GpsCoordinateFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEC\0\u{1}DMS\0\u{1}UTM\0\u{1}MGRS\0\u{1}OLC\0\u{1}OSGR\0")
}

extension Meshtastic_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Position"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}latitude_i\0\u{3}longitude_i\0\u{1}altitude\0\u{1}time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularSFixed32Field(value: &self.latitudeI) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self.longitudeI) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.altitude) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitudeI != 0 {
      try visitor.visitSingularSFixed32Field(value: self.latitudeI, fieldNumber: 1)
    }
    if self.longitudeI != 0 {
      try visitor.visitSingularSFixed32Field(value: self.longitudeI, fieldNumber: 2)
    }
    if self.altitude != 0 {
      try visitor.visitSingularInt32Field(value: self.altitude, fieldNumber: 3)
    }
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_Position, rhs: Meshtastic_Position) -> Bool {
    if lhs.latitudeI != rhs.latitudeI {return false}
    if lhs.longitudeI != rhs.longitudeI {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}long_name\0\u{3}short_name\0\u{1}macaddr\0\u{3}hw_model\0\u{3}is_licensed\0\u{1}role\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.macaddr) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.hwModel) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isLicensed) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
    }
    if !self.macaddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.macaddr, fieldNumber: 4)
    }
    if self.hwModel != .unset {
      try visitor.visitSingularEnumField(value: self.hwModel, fieldNumber: 5)
    }
    if self.isLicensed != false {
      try visitor.visitSingularBoolField(value: self.isLicensed, fieldNumber: 6)
    }
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_User, rhs: Meshtastic_User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.macaddr != rhs.macaddr {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs.isLicensed != rhs.isLicensed {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_RouteDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteDiscovery"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}route\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.route, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_RouteDiscovery, rhs: Meshtastic_RouteDiscovery) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Data"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}portnum\0\u{1}payload\0\u{3}want_response\0\u{1}dest\0\u{1}source\0\u{3}request_id\0\u{3}reply_id\0\u{1}emoji\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wantResponse) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.dest) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self.source) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self.replyID) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.portnum != 0 {
      try visitor.visitSingularUInt32Field(value: self.portnum, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if self.wantResponse != false {
      try visitor.visitSingularBoolField(value: self.wantResponse, fieldNumber: 3)
    }
    if self.dest != 0 {
      try visitor.visitSingularFixed32Field(value: self.dest, fieldNumber: 4)
    }
    if self.source != 0 {
      try visitor.visitSingularFixed32Field(value: self.source, fieldNumber: 5)
    }
    if self.requestID != 0 {
      try visitor.visitSingularFixed32Field(value: self.requestID, fieldNumber: 6)
    }
    if self.replyID != 0 {
      try visitor.visitSingularFixed32Field(value: self.replyID, fieldNumber: 7)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularBytesField(value: self.emoji, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_Data, rhs: Meshtastic_Data) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.wantResponse != rhs.wantResponse {return false}
    if lhs.dest != rhs.dest {return false}
    if lhs.source != rhs.source {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.replyID != rhs.replyID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_Routing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Routing"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}route_request\0\u{3}route_reply\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Meshtastic_RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeRequest(v)
        }
      }()
      case 2: try {
        var v: Meshtastic_RouteDiscovery?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .routeReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .routeReply(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .routeRequest?: try {
      guard case .routeRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .routeReply?: try {
      guard case .routeReply(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_Routing, rhs: Meshtastic_Routing) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_MeshPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MeshPacket"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}from\0\u{1}to\0\u{1}channel\0\u{1}decoded\0\u{1}encrypted\0\u{1}id\0\u{3}rx_time\0\u{3}rx_snr\0\u{3}rx_rssi\0\u{3}hop_limit\0\u{3}want_ack\0\u{1}priority\0\u{3}hop_start\0\u{3}via_mqtt\0")

  fileprivate class _StorageClass {
    var _from: UInt32 = 0
    var _to: UInt32 = 0
    var _channel: UInt32 = 0
    var _payloadVariant: Meshtastic_MeshPacket.OneOf_PayloadVariant?
    var _id: UInt32 = 0
    var _rxTime: UInt32 = 0
    var _rxSnr: Float = 0
    var _rxRssi: Int32 = 0
    var _hopLimit: UInt32 = 0
    var _wantAck: Bool = false
    var _priority: Meshtastic_Priority = .unsetPriority
    var _hopStart: Int32 = 0
    var _viaMqtt: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _to = source._to
      _channel = source._channel
      _payloadVariant = source._payloadVariant
      _id = source._id
      _rxTime = source._rxTime
      _rxSnr = source._rxSnr
      _rxRssi = source._rxRssi
      _hopLimit = source._hopLimit
      _wantAck = source._wantAck
      _priority = source._priority
      _hopStart = source._hopStart
      _viaMqtt = source._viaMqtt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._from) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._to) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
        case 4: try {
          var v: Meshtastic_Data?
          var hadOneofValue = false
          if let current = _storage._payloadVariant {
            hadOneofValue = true
            if case .decoded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .decoded(v)
          }
        }()
        case 5: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._payloadVariant != nil {try decoder.handleConflictingOneOf()}
            _storage._payloadVariant = .encrypted(v)
          }
        }()
        case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._id) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._rxTime) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._rxSnr) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._rxRssi) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._wantAck) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._hopStart) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._viaMqtt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._from != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._from, fieldNumber: 1)
      }
      if _storage._to != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._to, fieldNumber: 2)
      }
      if _storage._channel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 3)
      }
      switch _storage._payloadVariant {
      case .decoded?: try {
        guard case .decoded(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .encrypted?: try {
        guard case .encrypted(let v)? = _storage._payloadVariant else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if _storage._id != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._id, fieldNumber: 6)
      }
      if _storage._rxTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rxTime, fieldNumber: 7)
      }
      if _storage._rxSnr.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._rxSnr, fieldNumber: 8)
      }
      if _storage._rxRssi != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rxRssi, fieldNumber: 9)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 10)
      }
      if _storage._wantAck != false {
        try visitor.visitSingularBoolField(value: _storage._wantAck, fieldNumber: 11)
      }
      if _storage._priority != .unsetPriority {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 12)
      }
      if _storage._hopStart != 0 {
        try visitor.visitSingularInt32Field(value: _storage._hopStart, fieldNumber: 13)
      }
      if _storage._viaMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._viaMqtt, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_MeshPacket, rhs: Meshtastic_MeshPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._payloadVariant != rhs_storage._payloadVariant {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._rxTime != rhs_storage._rxTime {return false}
        if _storage._rxSnr != rhs_storage._rxSnr {return false}
        if _storage._rxRssi != rhs_storage._rxRssi {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._wantAck != rhs_storage._wantAck {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._hopStart != rhs_storage._hopStart {return false}
        if _storage._viaMqtt != rhs_storage._viaMqtt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}num\0\u{1}user\0\u{1}position\0\u{1}snr\0\u{3}last_heard\0\u{3}device_metrics\0\u{1}channel\0\u{3}via_mqtt\0\u{3}hops_away\0\u{3}is_favorite\0")

  fileprivate class _StorageClass {
    var _num: UInt32 = 0
    var _user: Meshtastic_User? = nil
    var _position: Meshtastic_Position? = nil
    var _snr: Float = 0
    var _lastHeard: Int32 = 0
    var _deviceMetrics: Meshtastic_DeviceMetrics? = nil
    var _channel: UInt32 = 0
    var _viaMqtt: Bool = false
    var _hopsAway: UInt32 = 0
    var _isFavorite: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _num = source._num
      _user = source._user
      _position = source._position
      _snr = source._snr
      _lastHeard = source._lastHeard
      _deviceMetrics = source._deviceMetrics
      _channel = source._channel
      _viaMqtt = source._viaMqtt
      _hopsAway = source._hopsAway
      _isFavorite = source._isFavorite
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._num) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._snr) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._lastHeard) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._deviceMetrics) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._channel) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._viaMqtt) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopsAway) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isFavorite) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._num != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._num, fieldNumber: 1)
      }
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._snr.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._snr, fieldNumber: 4)
      }
      if _storage._lastHeard != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lastHeard, fieldNumber: 5)
      }
      try { if let v = _storage._deviceMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._channel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channel, fieldNumber: 7)
      }
      if _storage._viaMqtt != false {
        try visitor.visitSingularBoolField(value: _storage._viaMqtt, fieldNumber: 8)
      }
      if _storage._hopsAway != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopsAway, fieldNumber: 9)
      }
      if _storage._isFavorite != false {
        try visitor.visitSingularBoolField(value: _storage._isFavorite, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_NodeInfo, rhs: Meshtastic_NodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._num != rhs_storage._num {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._snr != rhs_storage._snr {return false}
        if _storage._lastHeard != rhs_storage._lastHeard {return false}
        if _storage._deviceMetrics != rhs_storage._deviceMetrics {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._viaMqtt != rhs_storage._viaMqtt {return false}
        if _storage._hopsAway != rhs_storage._hopsAway {return false}
        if _storage._isFavorite != rhs_storage._isFavorite {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_MyNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MyNodeInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}my_node_num\0\u{3}reboot_count\0\u{3}min_app_version\0\u{3}max_channels\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.myNodeNum) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.rebootCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.minAppVersion) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.maxChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myNodeNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.myNodeNum, fieldNumber: 1)
    }
    if self.rebootCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rebootCount, fieldNumber: 2)
    }
    if self.minAppVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAppVersion, fieldNumber: 3)
    }
    if self.maxChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxChannels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_MyNodeInfo, rhs: Meshtastic_MyNodeInfo) -> Bool {
    if lhs.myNodeNum != rhs.myNodeNum {return false}
    if lhs.rebootCount != rhs.rebootCount {return false}
    if lhs.minAppVersion != rhs.minAppVersion {return false}
    if lhs.maxChannels != rhs.maxChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_DeviceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceMetrics"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}battery_level\0\u{1}voltage\0\u{3}channel_utilization\0\u{3}air_util_tx\0\u{3}uptime_seconds\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.batteryLevel) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.voltage) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.channelUtilization) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.airUtilTx) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.uptimeSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batteryLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryLevel, fieldNumber: 1)
    }
    if self.voltage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.voltage, fieldNumber: 2)
    }
    if self.channelUtilization.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.channelUtilization, fieldNumber: 3)
    }
    if self.airUtilTx.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.airUtilTx, fieldNumber: 4)
    }
    if self.uptimeSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.uptimeSeconds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_DeviceMetrics, rhs: Meshtastic_DeviceMetrics) -> Bool {
    if lhs.batteryLevel != rhs.batteryLevel {return false}
    if lhs.voltage != rhs.voltage {return false}
    if lhs.channelUtilization != rhs.channelUtilization {return false}
    if lhs.airUtilTx != rhs.airUtilTx {return false}
    if lhs.uptimeSeconds != rhs.uptimeSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_FromRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromRadio"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}packet\0\u{3}my_info\0\u{3}node_info\0\u{1}config\0\u{3}module_config\0\u{1}channel\0\u{3}config_complete_id\0\u{1}rebooted\0\u{3}moduleconfig_complete_id\0\u{3}channels_complete_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try {
        var v: Meshtastic_MeshPacket?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .packet(v)
        }
      }()
      case 3: try {
        var v: Meshtastic_MyNodeInfo?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .myInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .myInfo(v)
        }
      }()
      case 4: try {
        var v: Meshtastic_NodeInfo?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .nodeInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .nodeInfo(v)
        }
      }()
      case 5: try {
        var v: Meshtastic_Config?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .config(v)
        }
      }()
      case 6: try {
        var v: Meshtastic_ModuleConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .moduleConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .moduleConfig(v)
        }
      }()
      case 7: try {
        var v: Meshtastic_Channel?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .channel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .channel(v)
        }
      }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .configCompleteID(v)
        }
      }()
      case 9: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rebooted(v)
        }
      }()
      case 10: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .moduleconfigCompleteID(v)
        }
      }()
      case 11: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .channelsCompleteID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    switch self.payloadVariant {
    case .packet?: try {
      guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .myInfo?: try {
      guard case .myInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .nodeInfo?: try {
      guard case .nodeInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .config?: try {
      guard case .config(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .moduleConfig?: try {
      guard case .moduleConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .channel?: try {
      guard case .channel(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .configCompleteID?: try {
      guard case .configCompleteID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .rebooted?: try {
      guard case .rebooted(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }()
    case .moduleconfigCompleteID?: try {
      guard case .moduleconfigCompleteID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    }()
    case .channelsCompleteID?: try {
      guard case .channelsCompleteID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_FromRadio, rhs: Meshtastic_FromRadio) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_ToRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToRadio"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}packet\0\u{4}\u{2}want_config_id\0\u{1}disconnect\0\u{3}xmodem_packet\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Meshtastic_MeshPacket?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .packet(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .wantConfigID(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .disconnect(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payloadVariant != nil {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .xmodemPacket(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .packet?: try {
      guard case .packet(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wantConfigID?: try {
      guard case .wantConfigID(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .xmodemPacket?: try {
      guard case .xmodemPacket(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_ToRadio, rhs: Meshtastic_ToRadio) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}settings\0\u{1}role\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.role != .disabled {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_Channel, rhs: Meshtastic_Channel) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_ChannelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelSettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}channel_num\0\u{1}psk\0\u{1}name\0\u{1}id\0\u{3}uplink_enabled\0\u{3}downlink_enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.channelNum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.psk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.id) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.uplinkEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.downlinkEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelNum, fieldNumber: 1)
    }
    if !self.psk.isEmpty {
      try visitor.visitSingularBytesField(value: self.psk, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.id != 0 {
      try visitor.visitSingularFixed32Field(value: self.id, fieldNumber: 4)
    }
    if self.uplinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.uplinkEnabled, fieldNumber: 5)
    }
    if self.downlinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.downlinkEnabled, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_ChannelSettings, rhs: Meshtastic_ChannelSettings) -> Bool {
    if lhs.channelNum != rhs.channelNum {return false}
    if lhs.psk != rhs.psk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.uplinkEnabled != rhs.uplinkEnabled {return false}
    if lhs.downlinkEnabled != rhs.downlinkEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0\u{1}position\0\u{1}power\0\u{1}network\0\u{1}display\0\u{1}lora\0\u{1}bluetooth\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Meshtastic_DeviceConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .device(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .device(v)
        }
      }()
      case 2: try {
        var v: Meshtastic_PositionConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .position(v)
        }
      }()
      case 3: try {
        var v: Meshtastic_PowerConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .power(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .power(v)
        }
      }()
      case 4: try {
        var v: Meshtastic_NetworkConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .network(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .network(v)
        }
      }()
      case 5: try {
        var v: Meshtastic_DisplayConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .display(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .display(v)
        }
      }()
      case 6: try {
        var v: Meshtastic_LoRaConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .lora(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .lora(v)
        }
      }()
      case 7: try {
        var v: Meshtastic_BluetoothConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .bluetooth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .bluetooth(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .device?: try {
      guard case .device(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .position?: try {
      guard case .position(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .power?: try {
      guard case .power(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .network?: try {
      guard case .network(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .display?: try {
      guard case .display(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .lora?: try {
      guard case .lora(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bluetooth?: try {
      guard case .bluetooth(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_Config, rhs: Meshtastic_Config) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}role\0\u{3}serial_enabled\0\u{3}rebroadcast_mode\0\u{3}node_info_broadcast_secs\0\u{3}double_tap_as_button_press\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.serialEnabled) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rebroadcastMode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.nodeInfoBroadcastSecs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.doubleTapAsButtonPress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.role != .client {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    if self.serialEnabled != false {
      try visitor.visitSingularBoolField(value: self.serialEnabled, fieldNumber: 2)
    }
    if self.rebroadcastMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.rebroadcastMode, fieldNumber: 3)
    }
    if self.nodeInfoBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeInfoBroadcastSecs, fieldNumber: 4)
    }
    if self.doubleTapAsButtonPress != false {
      try visitor.visitSingularBoolField(value: self.doubleTapAsButtonPress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_DeviceConfig, rhs: Meshtastic_DeviceConfig) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.serialEnabled != rhs.serialEnabled {return false}
    if lhs.rebroadcastMode != rhs.rebroadcastMode {return false}
    if lhs.nodeInfoBroadcastSecs != rhs.nodeInfoBroadcastSecs {return false}
    if lhs.doubleTapAsButtonPress != rhs.doubleTapAsButtonPress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_PositionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}position_broadcast_secs\0\u{3}position_broadcast_smart_enabled\0\u{3}gps_update_interval\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.positionBroadcastSecs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.positionBroadcastSmartEnabled) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.gpsUpdateInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positionBroadcastSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.positionBroadcastSecs, fieldNumber: 1)
    }
    if self.positionBroadcastSmartEnabled != false {
      try visitor.visitSingularBoolField(value: self.positionBroadcastSmartEnabled, fieldNumber: 2)
    }
    if self.gpsUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsUpdateInterval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_PositionConfig, rhs: Meshtastic_PositionConfig) -> Bool {
    if lhs.positionBroadcastSecs != rhs.positionBroadcastSecs {return false}
    if lhs.positionBroadcastSmartEnabled != rhs.positionBroadcastSmartEnabled {return false}
    if lhs.gpsUpdateInterval != rhs.gpsUpdateInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_PowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PowerConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_power_saving\0\u{3}on_battery_shutdown_after_secs\0\u{3}adc_multiplier_override\0\u{3}wait_bluetooth_secs\0\u{3}sds_secs\0\u{3}ls_secs\0\u{3}min_wake_secs\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isPowerSaving) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.onBatteryShutdownAfterSecs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.adcMultiplierOverride) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.waitBluetoothSecs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sdsSecs) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.lsSecs) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.minWakeSecs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isPowerSaving != false {
      try visitor.visitSingularBoolField(value: self.isPowerSaving, fieldNumber: 1)
    }
    if self.onBatteryShutdownAfterSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.onBatteryShutdownAfterSecs, fieldNumber: 2)
    }
    if self.adcMultiplierOverride != 0 {
      try visitor.visitSingularUInt32Field(value: self.adcMultiplierOverride, fieldNumber: 3)
    }
    if self.waitBluetoothSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.waitBluetoothSecs, fieldNumber: 4)
    }
    if self.sdsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.sdsSecs, fieldNumber: 5)
    }
    if self.lsSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.lsSecs, fieldNumber: 6)
    }
    if self.minWakeSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.minWakeSecs, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_PowerConfig, rhs: Meshtastic_PowerConfig) -> Bool {
    if lhs.isPowerSaving != rhs.isPowerSaving {return false}
    if lhs.onBatteryShutdownAfterSecs != rhs.onBatteryShutdownAfterSecs {return false}
    if lhs.adcMultiplierOverride != rhs.adcMultiplierOverride {return false}
    if lhs.waitBluetoothSecs != rhs.waitBluetoothSecs {return false}
    if lhs.sdsSecs != rhs.sdsSecs {return false}
    if lhs.lsSecs != rhs.lsSecs {return false}
    if lhs.minWakeSecs != rhs.minWakeSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}wifi_enabled\0\u{3}wifi_ssid\0\u{3}wifi_psk\0\u{3}ntp_server\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wifiEnabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wifiSsid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.wifiPsk) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ntpServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wifiEnabled != false {
      try visitor.visitSingularBoolField(value: self.wifiEnabled, fieldNumber: 1)
    }
    if !self.wifiSsid.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiSsid, fieldNumber: 2)
    }
    if !self.wifiPsk.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiPsk, fieldNumber: 3)
    }
    if !self.ntpServer.isEmpty {
      try visitor.visitSingularStringField(value: self.ntpServer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_NetworkConfig, rhs: Meshtastic_NetworkConfig) -> Bool {
    if lhs.wifiEnabled != rhs.wifiEnabled {return false}
    if lhs.wifiSsid != rhs.wifiSsid {return false}
    if lhs.wifiPsk != rhs.wifiPsk {return false}
    if lhs.ntpServer != rhs.ntpServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_DisplayConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}screen_on_secs\0\u{3}auto_screen_carousel_secs\0\u{3}compass_north_top\0\u{3}flip_screen\0\u{3}gps_format\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.screenOnSecs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoScreenCarouselSecs) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.compassNorthTop) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.flipScreen) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gpsFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenOnSecs != 0 {
      try visitor.visitSingularUInt32Field(value: self.screenOnSecs, fieldNumber: 1)
    }
    if self.autoScreenCarouselSecs != false {
      try visitor.visitSingularBoolField(value: self.autoScreenCarouselSecs, fieldNumber: 2)
    }
    if self.compassNorthTop != false {
      try visitor.visitSingularBoolField(value: self.compassNorthTop, fieldNumber: 3)
    }
    if self.flipScreen != false {
      try visitor.visitSingularBoolField(value: self.flipScreen, fieldNumber: 4)
    }
    if self.gpsFormat != .dec {
      try visitor.visitSingularEnumField(value: self.gpsFormat, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_DisplayConfig, rhs: Meshtastic_DisplayConfig) -> Bool {
    if lhs.screenOnSecs != rhs.screenOnSecs {return false}
    if lhs.autoScreenCarouselSecs != rhs.autoScreenCarouselSecs {return false}
    if lhs.compassNorthTop != rhs.compassNorthTop {return false}
    if lhs.flipScreen != rhs.flipScreen {return false}
    if lhs.gpsFormat != rhs.gpsFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_LoRaConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoRaConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}use_preset\0\u{3}modem_preset\0\u{1}bandwidth\0\u{3}spread_factor\0\u{3}coding_rate\0\u{3}frequency_offset\0\u{1}region\0\u{3}hop_limit\0\u{3}tx_enabled\0\u{3}tx_power\0\u{3}channel_num\0\u{3}override_duty_cycle\0\u{3}sx126x_rx_boosted_gain\0\u{3}override_frequency\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.usePreset) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.modemPreset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.bandwidth) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.spreadFactor) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.codingRate) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.frequencyOffset) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.hopLimit) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.txEnabled) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.txPower) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.channelNum) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.overrideDutyCycle) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.sx126XRxBoostedGain) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.overrideFrequency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usePreset != false {
      try visitor.visitSingularBoolField(value: self.usePreset, fieldNumber: 1)
    }
    if self.modemPreset != .longFast {
      try visitor.visitSingularEnumField(value: self.modemPreset, fieldNumber: 2)
    }
    if self.bandwidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandwidth, fieldNumber: 3)
    }
    if self.spreadFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.spreadFactor, fieldNumber: 4)
    }
    if self.codingRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.codingRate, fieldNumber: 5)
    }
    if self.frequencyOffset != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequencyOffset, fieldNumber: 6)
    }
    if self.region != .unsetRegion {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 7)
    }
    if self.hopLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.hopLimit, fieldNumber: 8)
    }
    if self.txEnabled != false {
      try visitor.visitSingularBoolField(value: self.txEnabled, fieldNumber: 9)
    }
    if self.txPower.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.txPower, fieldNumber: 10)
    }
    if self.channelNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelNum, fieldNumber: 11)
    }
    if self.overrideDutyCycle != false {
      try visitor.visitSingularBoolField(value: self.overrideDutyCycle, fieldNumber: 12)
    }
    if self.sx126XRxBoostedGain != false {
      try visitor.visitSingularBoolField(value: self.sx126XRxBoostedGain, fieldNumber: 13)
    }
    if self.overrideFrequency != 0 {
      try visitor.visitSingularUInt32Field(value: self.overrideFrequency, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_LoRaConfig, rhs: Meshtastic_LoRaConfig) -> Bool {
    if lhs.usePreset != rhs.usePreset {return false}
    if lhs.modemPreset != rhs.modemPreset {return false}
    if lhs.bandwidth != rhs.bandwidth {return false}
    if lhs.spreadFactor != rhs.spreadFactor {return false}
    if lhs.codingRate != rhs.codingRate {return false}
    if lhs.frequencyOffset != rhs.frequencyOffset {return false}
    if lhs.region != rhs.region {return false}
    if lhs.hopLimit != rhs.hopLimit {return false}
    if lhs.txEnabled != rhs.txEnabled {return false}
    if lhs.txPower != rhs.txPower {return false}
    if lhs.channelNum != rhs.channelNum {return false}
    if lhs.overrideDutyCycle != rhs.overrideDutyCycle {return false}
    if lhs.sx126XRxBoostedGain != rhs.sx126XRxBoostedGain {return false}
    if lhs.overrideFrequency != rhs.overrideFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_BluetoothConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BluetoothConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}mode\0\u{3}fixed_pin\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fixedPin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 2)
    }
    if self.fixedPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.fixedPin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_BluetoothConfig, rhs: Meshtastic_BluetoothConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.fixedPin != rhs.fixedPin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_ModuleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mqtt\0\u{1}serial\0\u{3}external_notification\0\u{3}store_forward\0\u{3}range_test\0\u{1}telemetry\0\u{3}canned_message\0\u{1}audio\0\u{3}remote_hardware\0\u{3}neighbor_info\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Meshtastic_MQTTConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqtt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqtt(v)
        }
      }()
      case 2: try {
        var v: Meshtastic_SerialConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .serial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .serial(v)
        }
      }()
      case 3: try {
        var v: Meshtastic_ExternalNotificationConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .externalNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .externalNotification(v)
        }
      }()
      case 4: try {
        var v: Meshtastic_StoreForwardConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .storeForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .storeForward(v)
        }
      }()
      case 5: try {
        var v: Meshtastic_RangeTestConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .rangeTest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rangeTest(v)
        }
      }()
      case 6: try {
        var v: Meshtastic_TelemetryConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .telemetry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .telemetry(v)
        }
      }()
      case 7: try {
        var v: Meshtastic_CannedMessageConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .cannedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .cannedMessage(v)
        }
      }()
      case 8: try {
        var v: Meshtastic_AudioConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .audio(v)
        }
      }()
      case 9: try {
        var v: Meshtastic_RemoteHardwareConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .remoteHardware(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .remoteHardware(v)
        }
      }()
      case 10: try {
        var v: Meshtastic_NeighborInfoConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .neighborInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .neighborInfo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .mqtt?: try {
      guard case .mqtt(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .serial?: try {
      guard case .serial(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .externalNotification?: try {
      guard case .externalNotification(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .storeForward?: try {
      guard case .storeForward(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rangeTest?: try {
      guard case .rangeTest(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .telemetry?: try {
      guard case .telemetry(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cannedMessage?: try {
      guard case .cannedMessage(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .remoteHardware?: try {
      guard case .remoteHardware(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .neighborInfo?: try {
      guard case .neighborInfo(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_ModuleConfig, rhs: Meshtastic_ModuleConfig) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_MQTTConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MQTTConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}address\0\u{1}username\0\u{1}password\0\u{3}encryption_enabled\0\u{3}json_enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.encryptionEnabled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.jsonEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 4)
    }
    if self.encryptionEnabled != false {
      try visitor.visitSingularBoolField(value: self.encryptionEnabled, fieldNumber: 5)
    }
    if self.jsonEnabled != false {
      try visitor.visitSingularBoolField(value: self.jsonEnabled, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_MQTTConfig, rhs: Meshtastic_MQTTConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.address != rhs.address {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.encryptionEnabled != rhs.encryptionEnabled {return false}
    if lhs.jsonEnabled != rhs.jsonEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_SerialConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SerialConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}echo\0\u{1}rxd\0\u{1}txd\0\u{1}baud\0\u{1}timeout\0\u{1}mode\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.echo) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.rxd) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.txd) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.baud) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.echo != false {
      try visitor.visitSingularBoolField(value: self.echo, fieldNumber: 2)
    }
    if self.rxd != 0 {
      try visitor.visitSingularUInt32Field(value: self.rxd, fieldNumber: 3)
    }
    if self.txd != 0 {
      try visitor.visitSingularUInt32Field(value: self.txd, fieldNumber: 4)
    }
    if self.baud != 0 {
      try visitor.visitSingularUInt32Field(value: self.baud, fieldNumber: 5)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 6)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_SerialConfig, rhs: Meshtastic_SerialConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.echo != rhs.echo {return false}
    if lhs.rxd != rhs.rxd {return false}
    if lhs.txd != rhs.txd {return false}
    if lhs.baud != rhs.baud {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_ExternalNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExternalNotificationConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{3}output_ms\0\u{1}output\0\u{1}active\0\u{3}alert_message\0\u{3}alert_bell\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outputMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.output) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.alertMessage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.alertBell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.outputMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.outputMs, fieldNumber: 2)
    }
    if self.output != 0 {
      try visitor.visitSingularUInt32Field(value: self.output, fieldNumber: 3)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 4)
    }
    if self.alertMessage != false {
      try visitor.visitSingularBoolField(value: self.alertMessage, fieldNumber: 5)
    }
    if self.alertBell != false {
      try visitor.visitSingularBoolField(value: self.alertBell, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_ExternalNotificationConfig, rhs: Meshtastic_ExternalNotificationConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.outputMs != rhs.outputMs {return false}
    if lhs.output != rhs.output {return false}
    if lhs.active != rhs.active {return false}
    if lhs.alertMessage != rhs.alertMessage {return false}
    if lhs.alertBell != rhs.alertBell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_StoreForwardConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreForwardConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}heartbeat\0\u{1}records\0\u{3}history_return_max\0\u{3}history_return_window\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.heartbeat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.records) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnMax) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.historyReturnWindow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.heartbeat != false {
      try visitor.visitSingularBoolField(value: self.heartbeat, fieldNumber: 2)
    }
    if self.records != 0 {
      try visitor.visitSingularUInt32Field(value: self.records, fieldNumber: 3)
    }
    if self.historyReturnMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnMax, fieldNumber: 4)
    }
    if self.historyReturnWindow != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyReturnWindow, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_StoreForwardConfig, rhs: Meshtastic_StoreForwardConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.heartbeat != rhs.heartbeat {return false}
    if lhs.records != rhs.records {return false}
    if lhs.historyReturnMax != rhs.historyReturnMax {return false}
    if lhs.historyReturnWindow != rhs.historyReturnWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_RangeTestConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeTestConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}sender\0\u{1}save\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sender) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.save) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.sender != 0 {
      try visitor.visitSingularUInt32Field(value: self.sender, fieldNumber: 2)
    }
    if self.save != false {
      try visitor.visitSingularBoolField(value: self.save, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_RangeTestConfig, rhs: Meshtastic_RangeTestConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.save != rhs.save {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_TelemetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TelemetryConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_update_interval\0\u{3}environment_update_interval\0\u{3}environment_display_fahrenheit\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUpdateInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.environmentUpdateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.environmentDisplayFahrenheit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUpdateInterval, fieldNumber: 1)
    }
    if self.environmentUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentUpdateInterval, fieldNumber: 2)
    }
    if self.environmentDisplayFahrenheit != false {
      try visitor.visitSingularBoolField(value: self.environmentDisplayFahrenheit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_TelemetryConfig, rhs: Meshtastic_TelemetryConfig) -> Bool {
    if lhs.deviceUpdateInterval != rhs.deviceUpdateInterval {return false}
    if lhs.environmentUpdateInterval != rhs.environmentUpdateInterval {return false}
    if lhs.environmentDisplayFahrenheit != rhs.environmentDisplayFahrenheit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_CannedMessageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CannedMessageConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rotary1_enabled\0\u{3}inputbroker_pin_press\0\u{3}inputbroker_event_cw\0\u{3}inputbroker_event_ccw\0\u{3}inputbroker_event_press\0\u{3}updown1_enabled\0\u{1}enabled\0\u{3}allow_input_source\0\u{3}send_bell\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.rotary1Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerPinPress) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerEventCw) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerEventCcw) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.inputbrokerEventPress) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.updown1Enabled) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.allowInputSource) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.sendBell) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotary1Enabled != false {
      try visitor.visitSingularBoolField(value: self.rotary1Enabled, fieldNumber: 1)
    }
    if self.inputbrokerPinPress != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerPinPress, fieldNumber: 2)
    }
    if self.inputbrokerEventCw != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerEventCw, fieldNumber: 3)
    }
    if self.inputbrokerEventCcw != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerEventCcw, fieldNumber: 4)
    }
    if self.inputbrokerEventPress != 0 {
      try visitor.visitSingularUInt32Field(value: self.inputbrokerEventPress, fieldNumber: 5)
    }
    if self.updown1Enabled != false {
      try visitor.visitSingularBoolField(value: self.updown1Enabled, fieldNumber: 6)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 7)
    }
    if !self.allowInputSource.isEmpty {
      try visitor.visitSingularStringField(value: self.allowInputSource, fieldNumber: 8)
    }
    if self.sendBell != false {
      try visitor.visitSingularBoolField(value: self.sendBell, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_CannedMessageConfig, rhs: Meshtastic_CannedMessageConfig) -> Bool {
    if lhs.rotary1Enabled != rhs.rotary1Enabled {return false}
    if lhs.inputbrokerPinPress != rhs.inputbrokerPinPress {return false}
    if lhs.inputbrokerEventCw != rhs.inputbrokerEventCw {return false}
    if lhs.inputbrokerEventCcw != rhs.inputbrokerEventCcw {return false}
    if lhs.inputbrokerEventPress != rhs.inputbrokerEventPress {return false}
    if lhs.updown1Enabled != rhs.updown1Enabled {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowInputSource != rhs.allowInputSource {return false}
    if lhs.sendBell != rhs.sendBell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_AudioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}codec2_enabled\0\u{3}ptt_pin\0\u{1}bitrate\0\u{3}i2s_ws\0\u{3}i2s_sd\0\u{3}i2s_din\0\u{3}i2s_sck\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.codec2Enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pttPin) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.bitrate) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.i2SWs) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSd) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.i2SDin) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.i2SSck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codec2Enabled != false {
      try visitor.visitSingularBoolField(value: self.codec2Enabled, fieldNumber: 1)
    }
    if self.pttPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.pttPin, fieldNumber: 2)
    }
    if self.bitrate != false {
      try visitor.visitSingularBoolField(value: self.bitrate, fieldNumber: 3)
    }
    if self.i2SWs != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SWs, fieldNumber: 4)
    }
    if self.i2SSd != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSd, fieldNumber: 5)
    }
    if self.i2SDin != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SDin, fieldNumber: 6)
    }
    if self.i2SSck != 0 {
      try visitor.visitSingularUInt32Field(value: self.i2SSck, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_AudioConfig, rhs: Meshtastic_AudioConfig) -> Bool {
    if lhs.codec2Enabled != rhs.codec2Enabled {return false}
    if lhs.pttPin != rhs.pttPin {return false}
    if lhs.bitrate != rhs.bitrate {return false}
    if lhs.i2SWs != rhs.i2SWs {return false}
    if lhs.i2SSd != rhs.i2SSd {return false}
    if lhs.i2SDin != rhs.i2SDin {return false}
    if lhs.i2SSck != rhs.i2SSck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_RemoteHardwareConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteHardwareConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{3}allow_undefined_pin_access\0\u{3}available_pins\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowUndefinedPinAccess) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.availablePins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.allowUndefinedPinAccess != false {
      try visitor.visitSingularBoolField(value: self.allowUndefinedPinAccess, fieldNumber: 2)
    }
    if !self.availablePins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availablePins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_RemoteHardwareConfig, rhs: Meshtastic_RemoteHardwareConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allowUndefinedPinAccess != rhs.allowUndefinedPinAccess {return false}
    if lhs.availablePins != rhs.availablePins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_RemoteHardwarePin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteHardwarePin"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}gpio_pin\0\u{1}name\0\u{1}type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gpioPin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gpioPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpioPin, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_RemoteHardwarePin, rhs: Meshtastic_RemoteHardwarePin) -> Bool {
    if lhs.gpioPin != rhs.gpioPin {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Meshtastic_NeighborInfoConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NeighborInfoConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{3}update_interval\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.updateInterval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.updateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.updateInterval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meshtastic_NeighborInfoConfig, rhs: Meshtastic_NeighborInfoConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.updateInterval != rhs.updateInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
