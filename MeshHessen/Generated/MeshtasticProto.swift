// Generated by hand from mesh.proto + admin.proto + portnums.proto
// Run `protoc --swift_out=. mesh.proto admin.proto portnums.proto` to regenerate
// with SwiftProtobuf plugin installed.

import Foundation
import SwiftProtobuf

// MARK: - Position

struct Meshtastic_Position: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Position"
    var latitudeI: Int32 = 0
    var longitudeI: Int32 = 0
    var altitude: Int32 = 0
    var time: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularSFixed32Field(value: &latitudeI)
            case 2: try decoder.decodeSingularSFixed32Field(value: &longitudeI)
            case 3: try decoder.decodeSingularInt32Field(value: &altitude)
            case 4: try decoder.decodeSingularFixed32Field(value: &time)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if latitudeI != 0  { try visitor.visitSingularSFixed32Field(value: latitudeI, fieldNumber: 1) }
        if longitudeI != 0 { try visitor.visitSingularSFixed32Field(value: longitudeI, fieldNumber: 2) }
        if altitude != 0   { try visitor.visitSingularInt32Field(value: altitude, fieldNumber: 3) }
        if time != 0       { try visitor.visitSingularFixed32Field(value: time, fieldNumber: 4) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Position, rhs: Meshtastic_Position) -> Bool {
        lhs.latitudeI == rhs.latitudeI && lhs.longitudeI == rhs.longitudeI
    }
}

// MARK: - User

struct Meshtastic_User: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.User"
    var id: String = ""
    var longName: String = ""
    var shortName: String = ""
    var macaddr: Data = Data()
    var hwModel: Meshtastic_HardwareModel = .unset
    var isLicensed: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularStringField(value: &id)
            case 2: try decoder.decodeSingularStringField(value: &longName)
            case 3: try decoder.decodeSingularStringField(value: &shortName)
            case 4: try decoder.decodeSingularBytesField(value: &macaddr)
            case 5: try decoder.decodeSingularEnumField(value: &hwModel)
            case 6: try decoder.decodeSingularBoolField(value: &isLicensed)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !id.isEmpty       { try visitor.visitSingularStringField(value: id, fieldNumber: 1) }
        if !longName.isEmpty { try visitor.visitSingularStringField(value: longName, fieldNumber: 2) }
        if !shortName.isEmpty { try visitor.visitSingularStringField(value: shortName, fieldNumber: 3) }
        if !macaddr.isEmpty  { try visitor.visitSingularBytesField(value: macaddr, fieldNumber: 4) }
        if hwModel != .unset { try visitor.visitSingularEnumField(value: hwModel, fieldNumber: 5) }
        if isLicensed        { try visitor.visitSingularBoolField(value: isLicensed, fieldNumber: 6) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_User, rhs: Meshtastic_User) -> Bool { lhs.id == rhs.id }
}

// MARK: - HardwareModel

enum Meshtastic_HardwareModel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unset, tDeck, rak4631, tbeam
    case UNRECOGNIZED(Int)

    init() { self = .unset }
    init?(rawValue: Int) {
        switch rawValue {
        case 0:  self = .unset
        case 4:  self = .tbeam
        case 9:  self = .rak4631
        case 39: self = .tDeck
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    var rawValue: Int {
        switch self {
        case .unset:  return 0
        case .tbeam:  return 4
        case .rak4631: return 9
        case .tDeck:  return 39
        case .UNRECOGNIZED(let v): return v
        }
    }
    var name: String {
        switch self {
        case .unset:   return "Unknown"
        case .tbeam:   return "T-Beam"
        case .rak4631: return "RAK4631"
        case .tDeck:   return "T-Deck"
        case .UNRECOGNIZED(let v): return "HW(\(v))"
        }
    }
}

// MARK: - Data (Meshtastic)

struct Meshtastic_Data: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Data"
    var portnum: UInt32 = 0
    var payload: Data = Data()
    var wantResponse: Bool = false
    var dest: UInt32 = 0
    var source: UInt32 = 0
    var requestID: UInt32 = 0
    var replyID: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &portnum)
            case 2: try decoder.decodeSingularBytesField(value: &payload)
            case 3: try decoder.decodeSingularBoolField(value: &wantResponse)
            case 4: try decoder.decodeSingularFixed32Field(value: &dest)
            case 5: try decoder.decodeSingularFixed32Field(value: &source)
            case 6: try decoder.decodeSingularFixed32Field(value: &requestID)
            case 7: try decoder.decodeSingularFixed32Field(value: &replyID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if portnum != 0       { try visitor.visitSingularUInt32Field(value: portnum, fieldNumber: 1) }
        if !payload.isEmpty   { try visitor.visitSingularBytesField(value: payload, fieldNumber: 2) }
        if wantResponse       { try visitor.visitSingularBoolField(value: wantResponse, fieldNumber: 3) }
        if dest != 0          { try visitor.visitSingularFixed32Field(value: dest, fieldNumber: 4) }
        if source != 0        { try visitor.visitSingularFixed32Field(value: source, fieldNumber: 5) }
        if requestID != 0     { try visitor.visitSingularFixed32Field(value: requestID, fieldNumber: 6) }
        if replyID != 0       { try visitor.visitSingularFixed32Field(value: replyID, fieldNumber: 7) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Data, rhs: Meshtastic_Data) -> Bool {
        lhs.portnum == rhs.portnum && lhs.payload == rhs.payload
    }
}

// MARK: - MeshPacket

struct Meshtastic_MeshPacket: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.MeshPacket"
    var from: UInt32 = 0
    var to: UInt32 = 0
    var channel: UInt32 = 0
    var id: UInt32 = 0
    var rxTime: UInt32 = 0
    var rxSnr: Float = 0
    var rxRssi: Int32 = 0
    var hopLimit: UInt32 = 0
    var wantAck: Bool = false
    var viaMqtt: Bool = false
    var hopStart: Int32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case decoded(Meshtastic_Data)
        case encrypted(Data)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    var decoded: Meshtastic_Data {
        get { if case .decoded(let d) = payloadVariant { return d }; return Meshtastic_Data() }
        set { payloadVariant = .decoded(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularFixed32Field(value: &from)
            case 2: try decoder.decodeSingularFixed32Field(value: &to)
            case 3: try decoder.decodeSingularUInt32Field(value: &channel)
            case 4:
                var d = Meshtastic_Data()
                try decoder.decodeSingularMessageField(value: &d)
                payloadVariant = .decoded(d)
            case 5:
                var encrypted = Data()
                try decoder.decodeSingularBytesField(value: &encrypted)
                payloadVariant = .encrypted(encrypted)
            case 6: try decoder.decodeSingularFixed32Field(value: &id)
            case 7: try decoder.decodeSingularFixed32Field(value: &rxTime)
            case 8: try decoder.decodeSingularFloatField(value: &rxSnr)
            case 9: try decoder.decodeSingularInt32Field(value: &rxRssi)
            case 10: try decoder.decodeSingularUInt32Field(value: &hopLimit)
            case 11: try decoder.decodeSingularBoolField(value: &wantAck)
            case 13: try decoder.decodeSingularInt32Field(value: &hopStart)
            case 14: try decoder.decodeSingularBoolField(value: &viaMqtt)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if from != 0      { try visitor.visitSingularFixed32Field(value: from, fieldNumber: 1) }
        if to != 0        { try visitor.visitSingularFixed32Field(value: to, fieldNumber: 2) }
        if channel != 0   { try visitor.visitSingularUInt32Field(value: channel, fieldNumber: 3) }
        switch payloadVariant {
        case .decoded(let d):    try visitor.visitSingularMessageField(value: d, fieldNumber: 4)
        case .encrypted(let e):  try visitor.visitSingularBytesField(value: e, fieldNumber: 5)
        case .none: break
        }
        if id != 0        { try visitor.visitSingularFixed32Field(value: id, fieldNumber: 6) }
        if hopLimit != 0  { try visitor.visitSingularUInt32Field(value: hopLimit, fieldNumber: 10) }
        if wantAck        { try visitor.visitSingularBoolField(value: wantAck, fieldNumber: 11) }
        if viaMqtt        { try visitor.visitSingularBoolField(value: viaMqtt, fieldNumber: 14) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_MeshPacket, rhs: Meshtastic_MeshPacket) -> Bool { lhs.id == rhs.id }
}

// MARK: - DeviceMetrics

struct Meshtastic_DeviceMetrics: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.DeviceMetrics"
    var batteryLevel: UInt32 = 0
    var voltage: Float = 0
    var channelUtilization: Float = 0
    var airUtilTx: Float = 0
    var uptimeSeconds: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &batteryLevel)
            case 2: try decoder.decodeSingularFloatField(value: &voltage)
            case 3: try decoder.decodeSingularFloatField(value: &channelUtilization)
            case 4: try decoder.decodeSingularFloatField(value: &airUtilTx)
            case 5: try decoder.decodeSingularUInt32Field(value: &uptimeSeconds)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if batteryLevel != 0 { try visitor.visitSingularUInt32Field(value: batteryLevel, fieldNumber: 1) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_DeviceMetrics, rhs: Meshtastic_DeviceMetrics) -> Bool {
        lhs.batteryLevel == rhs.batteryLevel
    }
}

// MARK: - Telemetry (wrapper for DeviceMetrics, portnum 67)

struct Meshtastic_Telemetry: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Telemetry"
    var time: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum VariantOneOf {
        case deviceMetrics(Meshtastic_DeviceMetrics)
        case none
    }
    var variant: VariantOneOf = .none

    var deviceMetrics: Meshtastic_DeviceMetrics {
        get { if case .deviceMetrics(let m) = variant { return m }; return Meshtastic_DeviceMetrics() }
        set { variant = .deviceMetrics(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularFixed32Field(value: &time)
            case 2:
                var v = Meshtastic_DeviceMetrics()
                try decoder.decodeSingularMessageField(value: &v)
                variant = .deviceMetrics(v)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if time != 0 { try visitor.visitSingularFixed32Field(value: time, fieldNumber: 1) }
        if case .deviceMetrics(let m) = variant {
            try visitor.visitSingularMessageField(value: m, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Telemetry, rhs: Meshtastic_Telemetry) -> Bool {
        lhs.time == rhs.time
    }
}

// MARK: - NodeInfo

struct Meshtastic_NodeInfo: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.NodeInfo"
    var num: UInt32 = 0
    var user: Meshtastic_User = Meshtastic_User()
    var position: Meshtastic_Position = Meshtastic_Position()
    var snr: Float = 0
    var lastHeard: Int32 = 0
    var deviceMetrics: Meshtastic_DeviceMetrics = Meshtastic_DeviceMetrics()
    var channel: UInt32 = 0
    var viaMqtt: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &num)
            case 2: try decoder.decodeSingularMessageField(value: &user)
            case 3: try decoder.decodeSingularMessageField(value: &position)
            case 4: try decoder.decodeSingularFloatField(value: &snr)
            case 5: try decoder.decodeSingularInt32Field(value: &lastHeard)
            case 6: try decoder.decodeSingularMessageField(value: &deviceMetrics)
            case 7: try decoder.decodeSingularUInt32Field(value: &channel)
            case 8: try decoder.decodeSingularBoolField(value: &viaMqtt)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if num != 0 { try visitor.visitSingularUInt32Field(value: num, fieldNumber: 1) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_NodeInfo, rhs: Meshtastic_NodeInfo) -> Bool { lhs.num == rhs.num }
}

// MARK: - MyNodeInfo

struct Meshtastic_MyNodeInfo: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.MyNodeInfo"
    var myNodeNum: UInt32 = 0
    var rebootCount: UInt32 = 0
    var minAppVersion: UInt32 = 0
    var maxChannels: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &myNodeNum)
            case 2: try decoder.decodeSingularUInt32Field(value: &rebootCount)
            case 3: try decoder.decodeSingularUInt32Field(value: &minAppVersion)
            case 4: try decoder.decodeSingularUInt32Field(value: &maxChannels)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if myNodeNum != 0 { try visitor.visitSingularUInt32Field(value: myNodeNum, fieldNumber: 1) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_MyNodeInfo, rhs: Meshtastic_MyNodeInfo) -> Bool {
        lhs.myNodeNum == rhs.myNodeNum
    }
}

// MARK: - ChannelRole

enum Meshtastic_ChannelRole: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled, primary, secondary
    case UNRECOGNIZED(Int)

    init() { self = .disabled }
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .disabled
        case 1: self = .primary
        case 2: self = .secondary
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    var rawValue: Int {
        switch self {
        case .disabled: return 0
        case .primary:  return 1
        case .secondary: return 2
        case .UNRECOGNIZED(let v): return v
        }
    }
}

// MARK: - ChannelSettings

struct Meshtastic_ChannelSettings: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ChannelSettings"
    var channelNum: UInt32 = 0
    var psk: Data = Data()
    var name: String = ""
    var id: UInt32 = 0
    var uplinkEnabled: Bool = false
    var downlinkEnabled: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &channelNum)
            case 2: try decoder.decodeSingularBytesField(value: &psk)
            case 3: try decoder.decodeSingularStringField(value: &name)
            case 4: try decoder.decodeSingularFixed32Field(value: &id)
            case 5: try decoder.decodeSingularBoolField(value: &uplinkEnabled)
            case 6: try decoder.decodeSingularBoolField(value: &downlinkEnabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if channelNum != 0       { try visitor.visitSingularUInt32Field(value: channelNum, fieldNumber: 1) }
        if !psk.isEmpty          { try visitor.visitSingularBytesField(value: psk, fieldNumber: 2) }
        if !name.isEmpty         { try visitor.visitSingularStringField(value: name, fieldNumber: 3) }
        if id != 0               { try visitor.visitSingularFixed32Field(value: id, fieldNumber: 4) }
        if uplinkEnabled         { try visitor.visitSingularBoolField(value: uplinkEnabled, fieldNumber: 5) }
        if downlinkEnabled       { try visitor.visitSingularBoolField(value: downlinkEnabled, fieldNumber: 6) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ChannelSettings, rhs: Meshtastic_ChannelSettings) -> Bool {
        lhs.name == rhs.name && lhs.psk == rhs.psk
    }
}

// MARK: - Channel

struct Meshtastic_Channel: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Channel"
    var index: Int32 = 0
    var settings: Meshtastic_ChannelSettings = Meshtastic_ChannelSettings()
    var role: Meshtastic_ChannelRole = .disabled
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularInt32Field(value: &index)
            case 2: try decoder.decodeSingularMessageField(value: &settings)
            case 3: try decoder.decodeSingularEnumField(value: &role)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if index != 0    { try visitor.visitSingularInt32Field(value: index, fieldNumber: 1) }
        try visitor.visitSingularMessageField(value: settings, fieldNumber: 2)
        if role != .disabled { try visitor.visitSingularEnumField(value: role, fieldNumber: 3) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Channel, rhs: Meshtastic_Channel) -> Bool { lhs.index == rhs.index }
}

// MARK: - Region

enum Meshtastic_Region: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unset, us, eu868, cn, jp, anz, kr, tw, ru, `in`, nz865, th, ua868, my919, sg923, lora24
    case UNRECOGNIZED(Int)

    init() { self = .unset }
    init?(rawValue: Int) {
        switch rawValue {
        case 0:  self = .unset
        case 1:  self = .us
        case 3:  self = .eu868
        case 4:  self = .cn
        case 5:  self = .jp
        case 6:  self = .anz
        case 7:  self = .kr
        case 8:  self = .tw
        case 9:  self = .ru
        case 10: self = .in
        case 11: self = .nz865
        case 12: self = .th
        case 13: self = .ua868
        case 14: self = .my919
        case 15: self = .sg923
        case 16: self = .lora24
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    var rawValue: Int {
        switch self {
        case .unset:  return 0
        case .us:     return 1
        case .eu868:  return 3
        case .cn:     return 4
        case .jp:     return 5
        case .anz:    return 6
        case .kr:     return 7
        case .tw:     return 8
        case .ru:     return 9
        case .in:     return 10
        case .nz865:  return 11
        case .th:     return 12
        case .ua868:  return 13
        case .my919:  return 14
        case .sg923:  return 15
        case .lora24: return 16
        case .UNRECOGNIZED(let v): return v
        }
    }
    var name: String {
        switch self {
        case .unset:  return "Unset"
        case .us:     return "US"
        case .eu868:  return "EU_868"
        case .cn:     return "CN"
        case .jp:     return "JP"
        case .anz:    return "ANZ"
        case .kr:     return "KR"
        case .tw:     return "TW"
        case .ru:     return "RU"
        case .in:     return "IN"
        case .nz865:  return "NZ_865"
        case .th:     return "TH"
        case .ua868:  return "UA_868"
        case .my919:  return "MY_919"
        case .sg923:  return "SG_923"
        case .lora24: return "LoRa_2.4"
        case .UNRECOGNIZED(let v): return "Region(\(v))"
        }
    }
}

// MARK: - ModemPreset

enum Meshtastic_ModemPreset: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case longFast, longSlow, veryLongSlow, mediumSlow, mediumFast, shortSlow, shortFast, longModerate
    case UNRECOGNIZED(Int)

    init() { self = .longFast }
    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .longFast
        case 1: self = .longSlow
        case 2: self = .veryLongSlow
        case 3: self = .mediumSlow
        case 4: self = .mediumFast
        case 5: self = .shortSlow
        case 6: self = .shortFast
        case 7: self = .longModerate
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    var rawValue: Int {
        switch self {
        case .longFast:     return 0
        case .longSlow:     return 1
        case .veryLongSlow: return 2
        case .mediumSlow:   return 3
        case .mediumFast:   return 4
        case .shortSlow:    return 5
        case .shortFast:    return 6
        case .longModerate: return 7
        case .UNRECOGNIZED(let v): return v
        }
    }
    var name: String {
        switch self {
        case .longFast:     return "Long Fast"
        case .longSlow:     return "Long Slow"
        case .veryLongSlow: return "Very Long Slow"
        case .mediumSlow:   return "Medium Slow"
        case .mediumFast:   return "Medium Fast"
        case .shortSlow:    return "Short Slow"
        case .shortFast:    return "Short Fast"
        case .longModerate: return "Long Moderate"
        case .UNRECOGNIZED(let v): return "Modem(\(v))"
        }
    }
}

// MARK: - Config.DeviceConfig

struct Meshtastic_Config_DeviceConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.DeviceConfig"
    var role: UInt32 = 0
    var serialEnabled: Bool = false
    var rebroadcastMode: UInt32 = 0
    var nodeInfoBroadcastSecs: UInt32 = 0
    var doubleTapAsButtonPress: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &role)
            case 2: try decoder.decodeSingularBoolField(value: &serialEnabled)
            case 3: try decoder.decodeSingularUInt32Field(value: &rebroadcastMode)
            case 4: try decoder.decodeSingularUInt32Field(value: &nodeInfoBroadcastSecs)
            case 5: try decoder.decodeSingularBoolField(value: &doubleTapAsButtonPress)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if role != 0                 { try visitor.visitSingularUInt32Field(value: role, fieldNumber: 1) }
        if serialEnabled             { try visitor.visitSingularBoolField(value: serialEnabled, fieldNumber: 2) }
        if rebroadcastMode != 0      { try visitor.visitSingularUInt32Field(value: rebroadcastMode, fieldNumber: 3) }
        if nodeInfoBroadcastSecs != 0 { try visitor.visitSingularUInt32Field(value: nodeInfoBroadcastSecs, fieldNumber: 4) }
        if doubleTapAsButtonPress    { try visitor.visitSingularBoolField(value: doubleTapAsButtonPress, fieldNumber: 5) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_DeviceConfig, rhs: Meshtastic_Config_DeviceConfig) -> Bool {
        lhs.role == rhs.role
    }
}

// MARK: - Config.PositionConfig

struct Meshtastic_Config_PositionConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.PositionConfig"
    var positionBroadcastSecs: UInt32 = 0
    var positionBroadcastSmartEnabled: Bool = false
    var gpsUpdateInterval: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &positionBroadcastSecs)
            case 2: try decoder.decodeSingularBoolField(value: &positionBroadcastSmartEnabled)
            case 3: try decoder.decodeSingularUInt32Field(value: &gpsUpdateInterval)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if positionBroadcastSecs != 0        { try visitor.visitSingularUInt32Field(value: positionBroadcastSecs, fieldNumber: 1) }
        if positionBroadcastSmartEnabled     { try visitor.visitSingularBoolField(value: positionBroadcastSmartEnabled, fieldNumber: 2) }
        if gpsUpdateInterval != 0            { try visitor.visitSingularUInt32Field(value: gpsUpdateInterval, fieldNumber: 3) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_PositionConfig, rhs: Meshtastic_Config_PositionConfig) -> Bool {
        lhs.positionBroadcastSecs == rhs.positionBroadcastSecs
    }
}

// MARK: - Config.PowerConfig

struct Meshtastic_Config_PowerConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.PowerConfig"
    var isPowerSaving: Bool = false
    var onBatteryShutdownAfterSecs: UInt32 = 0
    var adcMultiplierOverride: UInt32 = 0
    var waitBluetoothSecs: UInt32 = 0
    var sdsSecs: UInt32 = 0
    var lsSecs: UInt32 = 0
    var minWakeSecs: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &isPowerSaving)
            case 2: try decoder.decodeSingularUInt32Field(value: &onBatteryShutdownAfterSecs)
            case 3: try decoder.decodeSingularUInt32Field(value: &adcMultiplierOverride)
            case 4: try decoder.decodeSingularUInt32Field(value: &waitBluetoothSecs)
            case 5: try decoder.decodeSingularUInt32Field(value: &sdsSecs)
            case 6: try decoder.decodeSingularUInt32Field(value: &lsSecs)
            case 7: try decoder.decodeSingularUInt32Field(value: &minWakeSecs)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if isPowerSaving                  { try visitor.visitSingularBoolField(value: isPowerSaving, fieldNumber: 1) }
        if onBatteryShutdownAfterSecs != 0 { try visitor.visitSingularUInt32Field(value: onBatteryShutdownAfterSecs, fieldNumber: 2) }
        if adcMultiplierOverride != 0     { try visitor.visitSingularUInt32Field(value: adcMultiplierOverride, fieldNumber: 3) }
        if waitBluetoothSecs != 0         { try visitor.visitSingularUInt32Field(value: waitBluetoothSecs, fieldNumber: 4) }
        if sdsSecs != 0                   { try visitor.visitSingularUInt32Field(value: sdsSecs, fieldNumber: 5) }
        if lsSecs != 0                    { try visitor.visitSingularUInt32Field(value: lsSecs, fieldNumber: 6) }
        if minWakeSecs != 0               { try visitor.visitSingularUInt32Field(value: minWakeSecs, fieldNumber: 7) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_PowerConfig, rhs: Meshtastic_Config_PowerConfig) -> Bool {
        lhs.isPowerSaving == rhs.isPowerSaving
    }
}

// MARK: - Config.NetworkConfig

struct Meshtastic_Config_NetworkConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.NetworkConfig"
    var wifiEnabled: Bool = false
    var wifiSsid: String = ""
    var wifiPsk: String = ""
    var ntpServer: String = ""
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &wifiEnabled)
            case 2: try decoder.decodeSingularStringField(value: &wifiSsid)
            case 3: try decoder.decodeSingularStringField(value: &wifiPsk)
            case 4: try decoder.decodeSingularStringField(value: &ntpServer)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if wifiEnabled       { try visitor.visitSingularBoolField(value: wifiEnabled, fieldNumber: 1) }
        if !wifiSsid.isEmpty { try visitor.visitSingularStringField(value: wifiSsid, fieldNumber: 2) }
        if !wifiPsk.isEmpty  { try visitor.visitSingularStringField(value: wifiPsk, fieldNumber: 3) }
        if !ntpServer.isEmpty { try visitor.visitSingularStringField(value: ntpServer, fieldNumber: 4) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_NetworkConfig, rhs: Meshtastic_Config_NetworkConfig) -> Bool {
        lhs.wifiSsid == rhs.wifiSsid
    }
}

// MARK: - Config.DisplayConfig

struct Meshtastic_Config_DisplayConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.DisplayConfig"
    var screenOnSecs: UInt32 = 0
    var autoScreenCarouselSecs: Bool = false
    var compassNorthTop: Bool = false
    var flipScreen: Bool = false
    var gpsFormat: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &screenOnSecs)
            case 2: try decoder.decodeSingularBoolField(value: &autoScreenCarouselSecs)
            case 3: try decoder.decodeSingularBoolField(value: &compassNorthTop)
            case 4: try decoder.decodeSingularBoolField(value: &flipScreen)
            case 5: try decoder.decodeSingularUInt32Field(value: &gpsFormat)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if screenOnSecs != 0       { try visitor.visitSingularUInt32Field(value: screenOnSecs, fieldNumber: 1) }
        if autoScreenCarouselSecs  { try visitor.visitSingularBoolField(value: autoScreenCarouselSecs, fieldNumber: 2) }
        if compassNorthTop         { try visitor.visitSingularBoolField(value: compassNorthTop, fieldNumber: 3) }
        if flipScreen              { try visitor.visitSingularBoolField(value: flipScreen, fieldNumber: 4) }
        if gpsFormat != 0          { try visitor.visitSingularUInt32Field(value: gpsFormat, fieldNumber: 5) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_DisplayConfig, rhs: Meshtastic_Config_DisplayConfig) -> Bool {
        lhs.screenOnSecs == rhs.screenOnSecs
    }
}

// MARK: - Config.LoRaConfig

struct Meshtastic_Config_LoRaConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.LoRaConfig"
    var usePreset: Bool = false
    var modemPreset: Meshtastic_ModemPreset = .longFast
    var bandwidth: UInt32 = 0
    var spreadFactor: UInt32 = 0
    var codingRate: UInt32 = 0
    var frequencyOffset: UInt32 = 0
    var region: Meshtastic_Region = .unset
    var hopLimit: UInt32 = 0
    var txEnabled: Bool = false
    var txPower: Float = 0
    var channelNum: UInt32 = 0
    var overrideDutyCycle: Bool = false
    var sx126xRxBoostedGain: Bool = false
    var overrideFrequency: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:  try decoder.decodeSingularBoolField(value: &usePreset)
            case 2:  try decoder.decodeSingularEnumField(value: &modemPreset)
            case 3:  try decoder.decodeSingularUInt32Field(value: &bandwidth)
            case 4:  try decoder.decodeSingularUInt32Field(value: &spreadFactor)
            case 5:  try decoder.decodeSingularUInt32Field(value: &codingRate)
            case 6:  try decoder.decodeSingularUInt32Field(value: &frequencyOffset)
            case 7:  try decoder.decodeSingularEnumField(value: &region)
            case 8:  try decoder.decodeSingularUInt32Field(value: &hopLimit)
            case 9:  try decoder.decodeSingularBoolField(value: &txEnabled)
            case 10: try decoder.decodeSingularFloatField(value: &txPower)
            case 11: try decoder.decodeSingularUInt32Field(value: &channelNum)
            case 12: try decoder.decodeSingularBoolField(value: &overrideDutyCycle)
            case 13: try decoder.decodeSingularBoolField(value: &sx126xRxBoostedGain)
            case 14: try decoder.decodeSingularUInt32Field(value: &overrideFrequency)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if usePreset                { try visitor.visitSingularBoolField(value: usePreset, fieldNumber: 1) }
        if modemPreset != .longFast { try visitor.visitSingularEnumField(value: modemPreset, fieldNumber: 2) }
        if bandwidth != 0           { try visitor.visitSingularUInt32Field(value: bandwidth, fieldNumber: 3) }
        if spreadFactor != 0        { try visitor.visitSingularUInt32Field(value: spreadFactor, fieldNumber: 4) }
        if codingRate != 0          { try visitor.visitSingularUInt32Field(value: codingRate, fieldNumber: 5) }
        if frequencyOffset != 0     { try visitor.visitSingularUInt32Field(value: frequencyOffset, fieldNumber: 6) }
        if region != .unset         { try visitor.visitSingularEnumField(value: region, fieldNumber: 7) }
        if hopLimit != 0            { try visitor.visitSingularUInt32Field(value: hopLimit, fieldNumber: 8) }
        if txEnabled                { try visitor.visitSingularBoolField(value: txEnabled, fieldNumber: 9) }
        if txPower != 0             { try visitor.visitSingularFloatField(value: txPower, fieldNumber: 10) }
        if channelNum != 0          { try visitor.visitSingularUInt32Field(value: channelNum, fieldNumber: 11) }
        if overrideDutyCycle        { try visitor.visitSingularBoolField(value: overrideDutyCycle, fieldNumber: 12) }
        if sx126xRxBoostedGain      { try visitor.visitSingularBoolField(value: sx126xRxBoostedGain, fieldNumber: 13) }
        if overrideFrequency != 0   { try visitor.visitSingularUInt32Field(value: overrideFrequency, fieldNumber: 14) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_LoRaConfig, rhs: Meshtastic_Config_LoRaConfig) -> Bool {
        lhs.region == rhs.region && lhs.modemPreset == rhs.modemPreset
    }
}

// MARK: - Config.BluetoothConfig

struct Meshtastic_Config_BluetoothConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config.BluetoothConfig"
    var enabled: Bool = false
    var mode: UInt32 = 0
    var fixedPin: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &mode)
            case 3: try decoder.decodeSingularUInt32Field(value: &fixedPin)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled       { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if mode != 0     { try visitor.visitSingularUInt32Field(value: mode, fieldNumber: 2) }
        if fixedPin != 0 { try visitor.visitSingularUInt32Field(value: fixedPin, fieldNumber: 3) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config_BluetoothConfig, rhs: Meshtastic_Config_BluetoothConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - Config

struct Meshtastic_Config: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.Config"
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case device(Meshtastic_Config_DeviceConfig)
        case position(Meshtastic_Config_PositionConfig)
        case power(Meshtastic_Config_PowerConfig)
        case network(Meshtastic_Config_NetworkConfig)
        case display(Meshtastic_Config_DisplayConfig)
        case lora(Meshtastic_Config_LoRaConfig)
        case bluetooth(Meshtastic_Config_BluetoothConfig)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    var lora: Meshtastic_Config_LoRaConfig {
        get { if case .lora(let v) = payloadVariant { return v }; return Meshtastic_Config_LoRaConfig() }
        set { payloadVariant = .lora(newValue) }
    }

    var device: Meshtastic_Config_DeviceConfig {
        get { if case .device(let v) = payloadVariant { return v }; return Meshtastic_Config_DeviceConfig() }
        set { payloadVariant = .device(newValue) }
    }

    var network: Meshtastic_Config_NetworkConfig {
        get { if case .network(let v) = payloadVariant { return v }; return Meshtastic_Config_NetworkConfig() }
        set { payloadVariant = .network(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:
                var v = Meshtastic_Config_DeviceConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .device(v)
            case 2:
                var v = Meshtastic_Config_PositionConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .position(v)
            case 3:
                var v = Meshtastic_Config_PowerConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .power(v)
            case 4:
                var v = Meshtastic_Config_NetworkConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .network(v)
            case 5:
                var v = Meshtastic_Config_DisplayConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .display(v)
            case 6:
                var v = Meshtastic_Config_LoRaConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .lora(v)
            case 7:
                var v = Meshtastic_Config_BluetoothConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .bluetooth(v)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        switch payloadVariant {
        case .device(let v):    try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        case .position(let v):  try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        case .power(let v):     try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        case .network(let v):   try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        case .display(let v):   try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        case .lora(let v):      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        case .bluetooth(let v): try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        case .none: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_Config, rhs: Meshtastic_Config) -> Bool { true }
}

// MARK: - ModuleConfig.MQTTConfig

struct Meshtastic_ModuleConfig_MQTTConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.MQTTConfig"
    var enabled: Bool = false
    var address: String = ""
    var username: String = ""
    var password: String = ""
    var encryptionEnabled: Bool = false
    var jsonEnabled: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularStringField(value: &address)
            case 3: try decoder.decodeSingularStringField(value: &username)
            case 4: try decoder.decodeSingularStringField(value: &password)
            case 5: try decoder.decodeSingularBoolField(value: &encryptionEnabled)
            case 6: try decoder.decodeSingularBoolField(value: &jsonEnabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled              { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if !address.isEmpty     { try visitor.visitSingularStringField(value: address, fieldNumber: 2) }
        if !username.isEmpty    { try visitor.visitSingularStringField(value: username, fieldNumber: 3) }
        if !password.isEmpty    { try visitor.visitSingularStringField(value: password, fieldNumber: 4) }
        if encryptionEnabled    { try visitor.visitSingularBoolField(value: encryptionEnabled, fieldNumber: 5) }
        if jsonEnabled          { try visitor.visitSingularBoolField(value: jsonEnabled, fieldNumber: 6) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_MQTTConfig, rhs: Meshtastic_ModuleConfig_MQTTConfig) -> Bool {
        lhs.enabled == rhs.enabled && lhs.address == rhs.address
    }
}

// MARK: - ModuleConfig.SerialConfig

struct Meshtastic_ModuleConfig_SerialConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.SerialConfig"
    var enabled: Bool = false
    var echo: Bool = false
    var rxd: UInt32 = 0
    var txd: UInt32 = 0
    var baud: UInt32 = 0
    var timeout: UInt32 = 0
    var mode: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularBoolField(value: &echo)
            case 3: try decoder.decodeSingularUInt32Field(value: &rxd)
            case 4: try decoder.decodeSingularUInt32Field(value: &txd)
            case 5: try decoder.decodeSingularUInt32Field(value: &baud)
            case 6: try decoder.decodeSingularUInt32Field(value: &timeout)
            case 7: try decoder.decodeSingularUInt32Field(value: &mode)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled       { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if echo          { try visitor.visitSingularBoolField(value: echo, fieldNumber: 2) }
        if rxd != 0      { try visitor.visitSingularUInt32Field(value: rxd, fieldNumber: 3) }
        if txd != 0      { try visitor.visitSingularUInt32Field(value: txd, fieldNumber: 4) }
        if baud != 0     { try visitor.visitSingularUInt32Field(value: baud, fieldNumber: 5) }
        if timeout != 0  { try visitor.visitSingularUInt32Field(value: timeout, fieldNumber: 6) }
        if mode != 0     { try visitor.visitSingularUInt32Field(value: mode, fieldNumber: 7) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_SerialConfig, rhs: Meshtastic_ModuleConfig_SerialConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.ExternalNotificationConfig

struct Meshtastic_ModuleConfig_ExternalNotificationConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.ExternalNotificationConfig"
    var enabled: Bool = false
    var outputMs: UInt32 = 0
    var output: UInt32 = 0
    var active: Bool = false
    var alertMessage: Bool = false
    var alertBell: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &outputMs)
            case 3: try decoder.decodeSingularUInt32Field(value: &output)
            case 4: try decoder.decodeSingularBoolField(value: &active)
            case 5: try decoder.decodeSingularBoolField(value: &alertMessage)
            case 6: try decoder.decodeSingularBoolField(value: &alertBell)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled      { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if outputMs != 0 { try visitor.visitSingularUInt32Field(value: outputMs, fieldNumber: 2) }
        if output != 0  { try visitor.visitSingularUInt32Field(value: output, fieldNumber: 3) }
        if active       { try visitor.visitSingularBoolField(value: active, fieldNumber: 4) }
        if alertMessage { try visitor.visitSingularBoolField(value: alertMessage, fieldNumber: 5) }
        if alertBell    { try visitor.visitSingularBoolField(value: alertBell, fieldNumber: 6) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_ExternalNotificationConfig, rhs: Meshtastic_ModuleConfig_ExternalNotificationConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.StoreForwardConfig

struct Meshtastic_ModuleConfig_StoreForwardConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.StoreForwardConfig"
    var enabled: Bool = false
    var heartbeat: Bool = false
    var records: UInt32 = 0
    var historyReturnMax: UInt32 = 0
    var historyReturnWindow: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularBoolField(value: &heartbeat)
            case 3: try decoder.decodeSingularUInt32Field(value: &records)
            case 4: try decoder.decodeSingularUInt32Field(value: &historyReturnMax)
            case 5: try decoder.decodeSingularUInt32Field(value: &historyReturnWindow)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled              { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if heartbeat            { try visitor.visitSingularBoolField(value: heartbeat, fieldNumber: 2) }
        if records != 0         { try visitor.visitSingularUInt32Field(value: records, fieldNumber: 3) }
        if historyReturnMax != 0 { try visitor.visitSingularUInt32Field(value: historyReturnMax, fieldNumber: 4) }
        if historyReturnWindow != 0 { try visitor.visitSingularUInt32Field(value: historyReturnWindow, fieldNumber: 5) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_StoreForwardConfig, rhs: Meshtastic_ModuleConfig_StoreForwardConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.RangeTestConfig

struct Meshtastic_ModuleConfig_RangeTestConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.RangeTestConfig"
    var enabled: Bool = false
    var sender: UInt32 = 0
    var save: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &sender)
            case 3: try decoder.decodeSingularBoolField(value: &save)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled      { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if sender != 0  { try visitor.visitSingularUInt32Field(value: sender, fieldNumber: 2) }
        if save         { try visitor.visitSingularBoolField(value: save, fieldNumber: 3) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_RangeTestConfig, rhs: Meshtastic_ModuleConfig_RangeTestConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.TelemetryConfig

struct Meshtastic_ModuleConfig_TelemetryConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.TelemetryConfig"
    var deviceUpdateInterval: UInt32 = 0
    var environmentUpdateInterval: UInt32 = 0
    var environmentDisplayFahrenheit: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularUInt32Field(value: &deviceUpdateInterval)
            case 2: try decoder.decodeSingularUInt32Field(value: &environmentUpdateInterval)
            case 3: try decoder.decodeSingularBoolField(value: &environmentDisplayFahrenheit)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if deviceUpdateInterval != 0      { try visitor.visitSingularUInt32Field(value: deviceUpdateInterval, fieldNumber: 1) }
        if environmentUpdateInterval != 0 { try visitor.visitSingularUInt32Field(value: environmentUpdateInterval, fieldNumber: 2) }
        if environmentDisplayFahrenheit   { try visitor.visitSingularBoolField(value: environmentDisplayFahrenheit, fieldNumber: 3) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_TelemetryConfig, rhs: Meshtastic_ModuleConfig_TelemetryConfig) -> Bool {
        lhs.deviceUpdateInterval == rhs.deviceUpdateInterval
    }
}

// MARK: - ModuleConfig.CannedMessageConfig

struct Meshtastic_ModuleConfig_CannedMessageConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.CannedMessageConfig"
    var rotary1Enabled: Bool = false
    var inputbrokerPinPress: UInt32 = 0
    var inputbrokerEventCw: UInt32 = 0
    var inputbrokerEventCcw: UInt32 = 0
    var inputbrokerEventPress: UInt32 = 0
    var updown1Enabled: Bool = false
    var enabled: Bool = false
    var allowInputSource: String = ""
    var sendBell: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &rotary1Enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &inputbrokerPinPress)
            case 3: try decoder.decodeSingularUInt32Field(value: &inputbrokerEventCw)
            case 4: try decoder.decodeSingularUInt32Field(value: &inputbrokerEventCcw)
            case 5: try decoder.decodeSingularUInt32Field(value: &inputbrokerEventPress)
            case 6: try decoder.decodeSingularBoolField(value: &updown1Enabled)
            case 7: try decoder.decodeSingularBoolField(value: &enabled)
            case 8: try decoder.decodeSingularStringField(value: &allowInputSource)
            case 9: try decoder.decodeSingularBoolField(value: &sendBell)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if rotary1Enabled           { try visitor.visitSingularBoolField(value: rotary1Enabled, fieldNumber: 1) }
        if inputbrokerPinPress != 0 { try visitor.visitSingularUInt32Field(value: inputbrokerPinPress, fieldNumber: 2) }
        if inputbrokerEventCw != 0  { try visitor.visitSingularUInt32Field(value: inputbrokerEventCw, fieldNumber: 3) }
        if inputbrokerEventCcw != 0 { try visitor.visitSingularUInt32Field(value: inputbrokerEventCcw, fieldNumber: 4) }
        if inputbrokerEventPress != 0 { try visitor.visitSingularUInt32Field(value: inputbrokerEventPress, fieldNumber: 5) }
        if updown1Enabled           { try visitor.visitSingularBoolField(value: updown1Enabled, fieldNumber: 6) }
        if enabled                  { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 7) }
        if !allowInputSource.isEmpty { try visitor.visitSingularStringField(value: allowInputSource, fieldNumber: 8) }
        if sendBell                 { try visitor.visitSingularBoolField(value: sendBell, fieldNumber: 9) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_CannedMessageConfig, rhs: Meshtastic_ModuleConfig_CannedMessageConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.AudioConfig

struct Meshtastic_ModuleConfig_AudioConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.AudioConfig"
    var codec2Enabled: Bool = false
    var pttPin: UInt32 = 0
    var bitrate: Bool = false
    var i2sWs: UInt32 = 0
    var i2sSd: UInt32 = 0
    var i2sDin: UInt32 = 0
    var i2sSck: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &codec2Enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &pttPin)
            case 3: try decoder.decodeSingularBoolField(value: &bitrate)
            case 4: try decoder.decodeSingularUInt32Field(value: &i2sWs)
            case 5: try decoder.decodeSingularUInt32Field(value: &i2sSd)
            case 6: try decoder.decodeSingularUInt32Field(value: &i2sDin)
            case 7: try decoder.decodeSingularUInt32Field(value: &i2sSck)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if codec2Enabled { try visitor.visitSingularBoolField(value: codec2Enabled, fieldNumber: 1) }
        if pttPin != 0   { try visitor.visitSingularUInt32Field(value: pttPin, fieldNumber: 2) }
        if bitrate       { try visitor.visitSingularBoolField(value: bitrate, fieldNumber: 3) }
        if i2sWs != 0    { try visitor.visitSingularUInt32Field(value: i2sWs, fieldNumber: 4) }
        if i2sSd != 0    { try visitor.visitSingularUInt32Field(value: i2sSd, fieldNumber: 5) }
        if i2sDin != 0   { try visitor.visitSingularUInt32Field(value: i2sDin, fieldNumber: 6) }
        if i2sSck != 0   { try visitor.visitSingularUInt32Field(value: i2sSck, fieldNumber: 7) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_AudioConfig, rhs: Meshtastic_ModuleConfig_AudioConfig) -> Bool {
        lhs.codec2Enabled == rhs.codec2Enabled
    }
}

// MARK: - ModuleConfig.RemoteHardwareConfig

struct Meshtastic_ModuleConfig_RemoteHardwareConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.RemoteHardwareConfig"
    var enabled: Bool = false
    var allowUndefinedPinAccess: Bool = false
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularBoolField(value: &allowUndefinedPinAccess)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled                  { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if allowUndefinedPinAccess  { try visitor.visitSingularBoolField(value: allowUndefinedPinAccess, fieldNumber: 2) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_RemoteHardwareConfig, rhs: Meshtastic_ModuleConfig_RemoteHardwareConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig.NeighborInfoConfig

struct Meshtastic_ModuleConfig_NeighborInfoConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig.NeighborInfoConfig"
    var enabled: Bool = false
    var updateInterval: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            case 2: try decoder.decodeSingularUInt32Field(value: &updateInterval)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled            { try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1) }
        if updateInterval != 0 { try visitor.visitSingularUInt32Field(value: updateInterval, fieldNumber: 2) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig_NeighborInfoConfig, rhs: Meshtastic_ModuleConfig_NeighborInfoConfig) -> Bool {
        lhs.enabled == rhs.enabled
    }
}

// MARK: - ModuleConfig

struct Meshtastic_ModuleConfig: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ModuleConfig"
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case mqtt(Meshtastic_ModuleConfig_MQTTConfig)
        case serial(Meshtastic_ModuleConfig_SerialConfig)
        case externalNotification(Meshtastic_ModuleConfig_ExternalNotificationConfig)
        case storeForward(Meshtastic_ModuleConfig_StoreForwardConfig)
        case rangeTest(Meshtastic_ModuleConfig_RangeTestConfig)
        case telemetry(Meshtastic_ModuleConfig_TelemetryConfig)
        case cannedMessage(Meshtastic_ModuleConfig_CannedMessageConfig)
        case audio(Meshtastic_ModuleConfig_AudioConfig)
        case remoteHardware(Meshtastic_ModuleConfig_RemoteHardwareConfig)
        case neighborInfo(Meshtastic_ModuleConfig_NeighborInfoConfig)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    var mqtt: Meshtastic_ModuleConfig_MQTTConfig {
        get { if case .mqtt(let v) = payloadVariant { return v }; return Meshtastic_ModuleConfig_MQTTConfig() }
        set { payloadVariant = .mqtt(newValue) }
    }

    var telemetry: Meshtastic_ModuleConfig_TelemetryConfig {
        get { if case .telemetry(let v) = payloadVariant { return v }; return Meshtastic_ModuleConfig_TelemetryConfig() }
        set { payloadVariant = .telemetry(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:
                var v = Meshtastic_ModuleConfig_MQTTConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .mqtt(v)
            case 2:
                var v = Meshtastic_ModuleConfig_SerialConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .serial(v)
            case 3:
                var v = Meshtastic_ModuleConfig_ExternalNotificationConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .externalNotification(v)
            case 4:
                var v = Meshtastic_ModuleConfig_StoreForwardConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .storeForward(v)
            case 5:
                var v = Meshtastic_ModuleConfig_RangeTestConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .rangeTest(v)
            case 6:
                var v = Meshtastic_ModuleConfig_TelemetryConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .telemetry(v)
            case 7:
                var v = Meshtastic_ModuleConfig_CannedMessageConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .cannedMessage(v)
            case 8:
                var v = Meshtastic_ModuleConfig_AudioConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .audio(v)
            case 9:
                var v = Meshtastic_ModuleConfig_RemoteHardwareConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .remoteHardware(v)
            case 10:
                var v = Meshtastic_ModuleConfig_NeighborInfoConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .neighborInfo(v)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        switch payloadVariant {
        case .mqtt(let v):                 try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        case .serial(let v):               try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        case .externalNotification(let v): try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        case .storeForward(let v):         try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        case .rangeTest(let v):            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        case .telemetry(let v):            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        case .cannedMessage(let v):        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        case .audio(let v):                try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
        case .remoteHardware(let v):       try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        case .neighborInfo(let v):         try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
        case .none: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ModuleConfig, rhs: Meshtastic_ModuleConfig) -> Bool { true }
}

// MARK: - FromRadio

struct Meshtastic_FromRadio: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.FromRadio"
    var id: UInt32 = 0
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case packet(Meshtastic_MeshPacket)
        case myInfo(Meshtastic_MyNodeInfo)
        case nodeInfo(Meshtastic_NodeInfo)
        case config(Meshtastic_Config)
        case moduleConfig(Meshtastic_ModuleConfig)
        case channel(Meshtastic_Channel)
        case configCompleteID(Data)
        case rebooted(Data)
        case moduleconfigCompleteID(Data)
        case channelsCompleteID(Data)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:
                try decoder.decodeSingularUInt32Field(value: &id)
            case 2:
                var v = Meshtastic_MeshPacket()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .packet(v)
            case 3:
                var v = Meshtastic_MyNodeInfo()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .myInfo(v)
            case 4:
                var v = Meshtastic_NodeInfo()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .nodeInfo(v)
            case 5:
                var v = Meshtastic_Config()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .config(v)
            case 6:
                var v = Meshtastic_ModuleConfig()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .moduleConfig(v)
            case 7:
                var v = Meshtastic_Channel()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .channel(v)
            case 8:
                var v = Data()
                try decoder.decodeSingularBytesField(value: &v)
                payloadVariant = .configCompleteID(v)
            case 9:
                var v = Data()
                try decoder.decodeSingularBytesField(value: &v)
                payloadVariant = .rebooted(v)
            case 10:
                var v = Data()
                try decoder.decodeSingularBytesField(value: &v)
                payloadVariant = .moduleconfigCompleteID(v)
            case 11:
                var v = Data()
                try decoder.decodeSingularBytesField(value: &v)
                payloadVariant = .channelsCompleteID(v)
            default:
                break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if id != 0 { try visitor.visitSingularUInt32Field(value: id, fieldNumber: 1) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_FromRadio, rhs: Meshtastic_FromRadio) -> Bool { lhs.id == rhs.id }
}

// MARK: - ToRadio

struct Meshtastic_ToRadio: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.ToRadio"
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case packet(Meshtastic_MeshPacket)
        case wantConfigID(UInt32)
        case disconnect(Bool)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    var packet: Meshtastic_MeshPacket {
        get { if case .packet(let p) = payloadVariant { return p }; return Meshtastic_MeshPacket() }
        set { payloadVariant = .packet(newValue) }
    }

    var wantConfigID: UInt32 {
        get { if case .wantConfigID(let v) = payloadVariant { return v }; return 0 }
        set { payloadVariant = .wantConfigID(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:
                var v = Meshtastic_MeshPacket()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .packet(v)
            case 3:
                var v: UInt32 = 0
                try decoder.decodeSingularUInt32Field(value: &v)
                payloadVariant = .wantConfigID(v)
            case 4:
                var v = false
                try decoder.decodeSingularBoolField(value: &v)
                payloadVariant = .disconnect(v)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        switch payloadVariant {
        case .packet(let p):      try visitor.visitSingularMessageField(value: p, fieldNumber: 1)
        case .wantConfigID(let v): try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
        case .disconnect(let v):  try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
        case .none: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_ToRadio, rhs: Meshtastic_ToRadio) -> Bool { true }
}

// MARK: - AdminMessage

struct Meshtastic_AdminMessage: SwiftProtobuf.Message {
    static let protoMessageName = "meshtastic.AdminMessage"
    var sessionPasskey: Data = Data()
    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PayloadVariant {
        case getChannelRequest(UInt32)
        case getChannelResponse(Meshtastic_Channel)
        case getOwnerRequest(Bool)
        case getConfigRequest(UInt32)
        case getConfigResponse(Meshtastic_Config)
        case setOwner(Meshtastic_User)
        case setChannel(Meshtastic_Channel)
        case setConfig(Meshtastic_Config)
        case none
    }
    var payloadVariant: PayloadVariant = .none

    var getChannelRequest: UInt32 {
        get { if case .getChannelRequest(let v) = payloadVariant { return v }; return 0 }
        set { payloadVariant = .getChannelRequest(newValue) }
    }

    var setChannel: Meshtastic_Channel {
        get { if case .setChannel(let v) = payloadVariant { return v }; return Meshtastic_Channel() }
        set { payloadVariant = .setChannel(newValue) }
    }

    var getConfigRequest: UInt32 {
        get { if case .getConfigRequest(let v) = payloadVariant { return v }; return 0 }
        set { payloadVariant = .getConfigRequest(newValue) }
    }

    init() {}

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNum = try decoder.nextFieldNumber() {
            switch fieldNum {
            case 1:
                var v: UInt32 = 0
                try decoder.decodeSingularUInt32Field(value: &v)
                payloadVariant = .getChannelRequest(v)
            case 2:
                var v = Meshtastic_Channel()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .getChannelResponse(v)
            case 5:
                var v: UInt32 = 0
                try decoder.decodeSingularUInt32Field(value: &v)
                payloadVariant = .getConfigRequest(v)
            case 33:
                var v = Meshtastic_Channel()
                try decoder.decodeSingularMessageField(value: &v)
                payloadVariant = .setChannel(v)
            case 101:
                try decoder.decodeSingularBytesField(value: &sessionPasskey)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        switch payloadVariant {
        case .getChannelRequest(let v): try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
        case .getChannelResponse(let v): try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        case .getConfigRequest(let v):  try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
        case .setChannel(let v):        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
        case .setConfig(let v):         try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
        case .setOwner(let v):          try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
        default: break
        }
        if !sessionPasskey.isEmpty { try visitor.visitSingularBytesField(value: sessionPasskey, fieldNumber: 101) }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Meshtastic_AdminMessage, rhs: Meshtastic_AdminMessage) -> Bool { true }
}
